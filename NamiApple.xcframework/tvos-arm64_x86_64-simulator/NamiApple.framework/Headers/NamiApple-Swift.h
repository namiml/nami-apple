#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
#ifndef NAMIAPPLE_SWIFT_H
#define NAMIAPPLE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import StoreKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="NamiApple",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

typedef SWIFT_ENUM(NSInteger, AccountStateAction, open) {
  AccountStateActionLogin = 0,
  AccountStateActionLogout = 1,
  AccountStateActionAdvertising_id_set = 2,
  AccountStateActionAdvertising_id_cleared = 3,
  AccountStateActionVendor_id_set = 4,
  AccountStateActionVendor_id_cleared = 5,
  AccountStateActionCustomer_data_platform_id_set = 6,
  AccountStateActionCustomer_data_platform_id_cleared = 7,
  AccountStateActionAnonymous_mode_on = 8,
  AccountStateActionAnonymous_mode_off = 9,
  AccountStateActionNami_device_id_set = 10,
  AccountStateActionNami_device_id_cleared = 11,
};

@class NSNumber;
@class NSCoder;

SWIFT_CLASS("_TtC9NamiApple20CustomerJourneyState")
@interface CustomerJourneyState : NSObject <NSCoding>
@property (nonatomic, readonly) BOOL formerSubscriber;
@property (nonatomic, readonly) BOOL inGracePeriod;
@property (nonatomic, readonly) BOOL inTrialPeriod;
@property (nonatomic, readonly) BOOL inIntroOfferPeriod;
@property (nonatomic, readonly) BOOL isCancelled;
@property (nonatomic, readonly) BOOL inPause;
@property (nonatomic, readonly) BOOL inAccountHold;
- (nonnull instancetype)initWithFormerSubscriber:(BOOL)formerSubscriber inGracePeriod:(BOOL)inGracePeriod inTrialPeriod:(BOOL)inTrialPeriod inIntroOfferPeriod:(BOOL)inIntroOfferPeriod isCancelled:(BOOL)isCancelled inPause:(BOOL)inPause inAccountHold:(BOOL)inAccountHold OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
@end



SWIFT_CLASS("_TtC9NamiApple12ImageService")
@interface ImageService : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




/// Possible campaign errors from the launch call.
typedef SWIFT_ENUM(NSInteger, LaunchCampaignError, open) {
  LaunchCampaignErrorDEFAULT_CAMPAIGN_NOT_FOUND = 0,
  LaunchCampaignErrorLABELED_CAMPAIGN_NOT_FOUND = 1,
  LaunchCampaignErrorCAMPAIGN_DATA_NOT_FOUND = 2,
  LaunchCampaignErrorPAYWALL_ALREADY_DISPLAYED = 3,
  LaunchCampaignErrorSDK_NOT_INITIALIZED = 4,
  LaunchCampaignErrorPAYWALL_COULD_NOT_DISPLAY = 5,
  LaunchCampaignErrorURL_CAMPAIGN_NOT_FOUND = 6,
  LaunchCampaignErrorPRODUCT_DATA_NOT_FOUND = 7,
  LaunchCampaignErrorPRODUCT_GROUPS_NOT_FOUND = 8,
};




/// This is the core Nami class, that handles central configuration across the Nami SDK
SWIFT_CLASS("_TtC9NamiApple4Nami")
@interface Nami : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) Nami * _Nonnull shared;)
+ (Nami * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NamiConfiguration;
enum NamiConfigureState : NSInteger;
enum NamiLogLevel : NSInteger;

@interface Nami (SWIFT_EXTENSION(NamiApple))
/// This is the initial call that activates the Nami SDK, it should be called as soon as possible within your app (preferably first in ApplicationDidFinishLaunching).
/// It is passed a configuration object that  defines at a minimum the App Platform ID Nami should use, but also other adjustments to how Nami should operate.
/// \param namiConfig NamiConfiguration object instance with appPlatformID set to value defined for this app in the Control Center.
///
+ (void)configureWith:(NamiConfiguration * _Nonnull)namiConfig :(void (^ _Nullable)(BOOL))sdkInitHandler;
/// This is the initial call that activates the Nami SDK, it should be called as soon as possible within your app (preferably first in ApplicationDidFinishLaunching).
/// It is passed a configuration object that  defines at a minimum the App Platform ID Nami should use, but also other adjustments to how Nami should operate.
/// \param namiConfig NamiConfiguration object instance with appPlatformID set to value defined for this app in the Control Center.
/// If called again during runtime, this method will evaluate what changes to the previous configuration occured and react accordingly.
///
+ (void)configureWithConfig:(NamiConfiguration * _Nonnull)namiConfig :(void (^ _Nullable)(BOOL, enum NamiConfigureState))sdkInitStateHandler;
/// Allows for dynamic re-adjustment of SDK log level if desired, from the log level set in the <code>NamiConfiguration</code> object.
/// \param logLevel New log level you wish to set, same as the log levels that can be set in the Nami.configure() call.
///
+ (void)setLogLevel:(enum NamiLogLevel)logLevel;
+ (BOOL)namiWindowEnabled SWIFT_WARN_UNUSED_RESULT;
/// Returns whether or not Nami is responsible for purchase management based upon the Nami account’s organization settings.
+ (BOOL)isPurchaseManagementEnabled SWIFT_WARN_UNUSED_RESULT;
+ (BOOL)sdkConfigured SWIFT_WARN_UNUSED_RESULT;
@end

@class NSString;

SWIFT_CLASS("_TtC9NamiApple12NamiCampaign")
@interface NamiCampaign : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
@property (nonatomic, copy) NSString * _Nonnull rule;
@property (nonatomic, copy) NSString * _Nonnull segment;
@property (nonatomic, copy) NSString * _Nonnull paywall;
@property (nonatomic, copy) NSString * _Nullable value;
@property (nonatomic, copy) NSString * _Nullable external_segment;
@property (nonatomic, copy) NSString * _Nullable name;
@end

@class NSURL;

SWIFT_CLASS("_TtC9NamiApple19NamiCampaignManager")
@interface NamiCampaignManager : NSObject
- (void)registerWithAvailableCampaignsHandler:(void (^ _Nullable)(NSArray<NamiCampaign *> * _Nonnull))availableCampaignsHandler;
/// Unregisters any active entilement change handlers..
+ (void)unregisterAvailableCampaignsHandler;
/// Registers a callback that will be activated when campaigns are loaded from cache or fetched from the Nami service.
/// \param availableCampaignsHandler A callback called when campaigns for this device are made available.
///
+ (void)registerAvailableCampaignsHandler:(void (^ _Nonnull)(NSArray<NamiCampaign *> * _Nonnull))availableCampaignsHandler;
/// Receive a list of all live campaigns sent to this device by the Nami service.
+ (NSArray<NamiCampaign *> * _Nonnull)allCampaigns SWIFT_WARN_UNUSED_RESULT;
/// Return true if a campaign with the supplied label is available on the device for launch
+ (BOOL)isCampaignAvailableWithLabel:(NSString * _Nonnull)label SWIFT_WARN_UNUSED_RESULT;
/// Return true if a campaign with the supplied label is available on the device for launch
+ (BOOL)isCampaignAvailableWithUrl:(NSURL * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// Return true if a campaign without a  label is available on the device for launch
+ (BOOL)isCampaignAvailable SWIFT_WARN_UNUSED_RESULT;
/// Asks Nami to update internal entitlements, if an action has been taken you feel might have affected entitlements recently and you would like to check.
+ (void)refresh;
/// Asks Nami to update internal entitlements, if an action has been taken you feel might have affected entitlements recently and you would like to check.
/// \param refreshHandler Called when the entitlement check has returned from Nami and system entitlments updated.
///
+ (void)refresh:(void (^ _Nullable)(NSArray<NamiCampaign *> * _Nonnull))refreshHandler;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PaywallLaunchContext;
@class NamiPaywallEvent;
@class UIViewController;

@interface NamiCampaignManager (SWIFT_EXTENSION(NamiApple))
/// Presents a paywall for the default campaign.
+ (void)launch;
/// Presents a paywall for a campain with a specific campaign label.
/// \param label Campaign label defined in Nami Control Center for launching a specific campaign.
///
+ (void)launchWithLabel:(NSString * _Nonnull)label;
/// Presents a paywall for a campaign with the selection of the paywall and paywall loading affected by the parameters passed in as listed below.
/// \param label Campaign label defined in Nami Control Center for launching a specific campaign.
///
/// \param launchHandler Handler to be invoked on success or if campaign cannot be launched due to an error.
///
/// \param paywallActionHandler Handler to be invoked when a paywall action occurs during this launch.
///
+ (void)launchWithLabel:(NSString * _Nullable)label context:(PaywallLaunchContext * _Nullable)context launchHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))launchHandler paywallActionHandler:(void (^ _Nullable)(NamiPaywallEvent * _Nonnull))paywallActionHandler;
/// Presents a paywall for a campaign with the selection of the paywall and paywall loading affected by the parameters passed in as listed below.
/// \param label Campaign label defined in Nami Control Center for launching a specific campaign.
///
/// \param viewController Optional provided view controller to present the paywall from.
///
/// \param context Optional PaywallLaunchContext which is used to contextual certain paywall templates.
///
/// \param launchHandler Handler to be invoked on success or if campaign cannot be launched due to an error.
///
/// \param paywallActionHandler Handler to be invoked when a paywall action occurs during this launch.
///
+ (void)launchWithLabel:(NSString * _Nullable)label viewController:(UIViewController * _Nullable)viewController context:(PaywallLaunchContext * _Nullable)context launchHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))launchHandler paywallActionHandler:(void (^ _Nullable)(NamiPaywallEvent * _Nonnull))paywallActionHandler;
/// Presents a paywall for a campaign with the selection of the paywall and paywall loading affected by the url passed in as listed below.
/// \param url Campaign url defined in Nami Control Center for launching a specific campaign.
///
/// \param viewController Optional provided view controller to present the paywall from.
///
/// \param context Optional PaywallLaunchContext which is used to contextual certain paywall templates.
///
/// \param launchHandler Handler to be invoked on success or if campaign cannot be launched due to an error.
///
/// \param paywallActionHandler Handler to be invoked when a paywall action occurs during this launch.
///
+ (void)launchWithUrl:(NSURL * _Nonnull)url viewController:(UIViewController * _Nullable)viewController context:(PaywallLaunchContext * _Nullable)context launchHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))launchHandler paywallActionHandler:(void (^ _Nullable)(NamiPaywallEvent * _Nonnull))paywallActionHandler;
@end


/// Configuration object to use with the Nami.configure() call.
SWIFT_CLASS("_TtC9NamiApple17NamiConfiguration")
@interface NamiConfiguration : NSObject
/// Alternate form of constructing a NamiConfiguration object, primarily used by ObjectiveC clients that cannot access the initializer.
/// \param appPlatformID The App Platform  ID for this app, obtained from the Control Center App Settings screen.
///
+ (NamiConfiguration * _Nonnull)configurationForAppPlatformId:(NSString * _Nonnull)appPlatformId SWIFT_WARN_UNUSED_RESULT;
/// The Nami App Platform ID to use for this app.
@property (nonatomic, readonly, copy) NSString * _Nonnull appPlatformId;
/// Defines what level of logging output that is desired from the Nami SDK.  Default is error.
@property (nonatomic) enum NamiLogLevel logLevel;
/// Declares the language of the desired configuration from the server, set from the possible set of values defined in NamiLanguageCodes.
@property (nonatomic, copy) NSString * _Nonnull namiLanguageCode;
/// Initial configuration used to help bootstrap the SDK on first run. Retrieve the intial config JSON file from
/// the Nami Control Center. Read in the JSON file as Data and pass the Data here.
@property (nonatomic, copy) NSString * _Nullable initialConfig;
/// Override the default behavior for how long a provisional entitlement grant will be valid before it expires.
/// If not provided, production purchases will grant a provisional entitlement for 24 hours. All other
/// purchases will grant for 3 minutes.
/// Override values need to be provided in seconds.
@property (nonatomic) double provisionalGrantTTL;
/// For customers using a custom instance of Nami with a unique hostname
@property (nonatomic, copy) NSString * _Nullable customHostname;
/// Used to activate internal features of the SDK not generally used by Nami customers.
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull namiCommands;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, NamiConfigureState, open) {
  NamiConfigureStateInitial_success = 0,
  NamiConfigureStateReconfig_success = 1,
  NamiConfigureStateAlready_configured = 2,
  NamiConfigureStateNot_configured = 3,
};


SWIFT_CLASS("_TtC9NamiApple19NamiCustomerManager")
@interface NamiCustomerManager : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSUUID;

@interface NamiCustomerManager (SWIFT_EXTENSION(NamiApple))
/// Reutrrns the set of current customer journey states.
///
/// returns:
/// An object continating various custoemr journey state items.
+ (CustomerJourneyState * _Nullable)journeyState SWIFT_WARN_UNUSED_RESULT;
/// Registers a callback that will be activated when any customer journey activity occurs
/// \param journeyStateHandler A callback called when customer journey changes in the system are detected.
///
+ (void)registerJourneyStateHandler:(void (^ _Nullable)(CustomerJourneyState * _Nonnull))journeyStateHandler;
/// Registers a callback that will be activated when any account state changes occur.
/// \param accountStateHandler A callback called when account state changes, or attempted changes, are detected.
///
+ (void)registerAccountStateHandler:(void (^ _Nullable)(enum AccountStateAction, BOOL, NSError * _Nullable))accountStateHandler;
/// Inform Nami about your app account ID used to log in a user.  Must be a SHA256 hash or UUID.  Will link this device to others that share the same app account.
/// \param withId A SHA256 hash or UUID you generate that identifies the app account for the user.
///
+ (void)loginWithId:(NSString * _Nonnull)id loginCompleteHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))loginCompleteHandler;
/// Returns <code>true</code> if any user is currently logged in to nami for this device.
+ (BOOL)isLoggedIn SWIFT_WARN_UNUSED_RESULT;
/// Returns the currently defined app account identifier for the device.
+ (NSString * _Nullable)loggedInId SWIFT_WARN_UNUSED_RESULT;
/// Logs the user out and clears the app account ID.
+ (void)logoutWithLogoutCompleteHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))logoutCompleteHandler;
/// Uniquie identifier used by Nami to identify this device. Please note, this value does not persist across app re-installs.
+ (NSString * _Nonnull)deviceId SWIFT_WARN_UNUSED_RESULT;
/// Allows users to opt-out of sending device-level data to the Nami service. Opted-in by default unless explicitly opted out.
/// <ul>
///   <li>
///     : anonymousMode:  A boolean that is true if the device has opted-out of device-level data.
///   </li>
/// </ul>
+ (void)setAnonymousMode:(BOOL)anonymousMode;
/// Returns whether or not the SDK is currently operating in anonymous mode
+ (BOOL)inAnonymousMode SWIFT_WARN_UNUSED_RESULT;
/// Returns whether or not this app platform id belongs to an anonymous mode capable Nami account.
+ (BOOL)anonymousModeCapability SWIFT_WARN_UNUSED_RESULT;
/// Allows you to pass the system Vendor ID to Nami
/// \param vendorId Advertising Identifier obtained from the system or your own custom UUID.
///
+ (void)setVendorIdWith:(NSUUID * _Nonnull)vendorId;
/// Clear a Vendor ID that has been sent to Nami
+ (void)clearVendorId;
/// Allows you to pass the system Advertising Identifier to Nami
/// \param advertisingId Advertising Identifier obtained from the system or your own custom UUID.
///
+ (void)setAdvertisingIdWith:(NSUUID * _Nonnull)advertisingId;
/// Clear a Advertising Identifier that has been sent to Nami
+ (void)clearAdvertisingId;
/// Allows you to pass your CDP Identifier to Nami
/// \param cdpId Identifier obtained from your Customer Data Platform.
///
+ (void)setCustomerDataPlatformIdWith:(NSString * _Nonnull)cdpId;
/// Clear a CDP Identifier that has been sent to Nami
+ (void)clearCustomerDataPlatformId;
/// Customer attributes are optional key/value pairs that can be used to personalize your Nami paywalls.
/// \param key The name of the attribute. For example: <code>firstName</code> or <code>favoriteTeam</code>
///
/// \param value The value of the attribute. For example: <code>Joe</code> or <code>Arsenal F.C.</code>
///
+ (void)setCustomerAttribute:(NSString * _Nonnull)key :(NSString * _Nonnull)value;
/// Clear a value  for a given key in the on-device customer attribute key/value store.
/// \param key The name of the attribute. For example: <code>firstName</code>
///
+ (void)clearCustomerAttribute:(NSString * _Nonnull)key;
/// Clear all customer attributes from the on-device key/value store.
+ (void)clearAllCustomerAttributes;
/// Get a value  for a given key in the on-device customer attribute key/value store.
/// \param key The name of the attribute. For example: <code>firstName</code>
///
+ (NSString * _Nullable)getCustomerAttributeWithKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
@end

@class NamiSKU;
@class NamiPurchase;

/// Entitlements grant access to features, content, or other aspects of your app.  Manage your entitlements in the Nami Control Center. Entitlements are associated with Product SKUs which are the specific in-app purchase products that grant an entitlement.
SWIFT_CLASS("_TtC9NamiApple15NamiEntitlement")
@interface NamiEntitlement : NSObject
/// Developer friendly name of entitlement
@property (nonatomic, copy) NSString * _Nullable name;
/// Description of entitlement
@property (nonatomic, copy) NSString * _Nullable desc;
/// The unique ID of the entitlement, use this to refer to the system when referencing an entitlements.
@property (nonatomic, copy) NSString * _Nonnull referenceId;
/// All SKU’s (StoreKit products or other) that grant this entitlement on purchase on this app platform.
@property (nonatomic, readonly, copy) NSArray<NamiSKU *> * _Nonnull relatedSkus;
/// List of NamiSKU objects that have been purchased and grant this entitlement.
@property (nonatomic, readonly, copy) NSArray<NamiSKU *> * _Nonnull purchasedSkus;
/// Purchase records for any purchased SKU.  Purchase records hold details like date of purchase, or subscription expiration.
@property (nonatomic, readonly, copy) NSArray<NamiPurchase *> * _Nonnull activePurchases;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC9NamiApple22NamiEntitlementManager")
@interface NamiEntitlementManager : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)registerWithActiveEntitlementsHandler:(void (^ _Nullable)(NSArray<NamiEntitlement *> * _Nonnull))activeEntitlementsHandler;
@end


@interface NamiEntitlementManager (SWIFT_EXTENSION(NamiApple))
/// Returns a list of all entitlements defined in the Control Center.  Note this includes both inactive and active entitlements. To see only active entitements use activeEntitlements().
///
/// returns:
/// array of all NamiEntitlements objects defined in the Control Center
+ (NSArray<NamiEntitlement *> * _Nonnull)available SWIFT_WARN_UNUSED_RESULT;
/// Returns a list of all active entitlements.  Nami checks entitlements across all platforms you have set up in the Control Center.  Use active entitlements to control access to different features in your app.
///
/// returns:
/// list of active NamiEntitlement objects.
+ (NSArray<NamiEntitlement *> * _Nonnull)active SWIFT_WARN_UNUSED_RESULT;
/// Check if a specific entitlement ID is active.
/// \param referenceID Entitlement ID to check.  Defined in the Control Center.
///
///
/// returns:
/// true if the entitlement matching the passed in ID is active, false otherwise.
+ (BOOL)isEntitlementActive:(NSString * _Nonnull)referenceId SWIFT_WARN_UNUSED_RESULT;
/// Asks Nami to update internal entitlements, if an action has been taken you feel might have affected entitlements recently and you would like to check.
+ (void)refresh;
/// Asks Nami to update internal entitlements, if an action has been taken you feel might have affected entitlements recently and you would like to check.
/// \param refreshHandler Called when the entitlement check has returned from Nami and system entitlments updated.
///
+ (void)refresh:(void (^ _Nullable)(NSArray<NamiEntitlement *> * _Nonnull))refreshHandler;
/// Unregisters any active entilement change handlers..
+ (void)unregisterActiveEntitlementsHandler;
/// Registers a callback that will be activated when any entitlement activity occurs - either added or removed.
/// \param changeHandler A callback called when entitlement changes in the system are detected.
///
+ (void)registerActiveEntitlementsHandler:(void (^ _Nonnull)(NSArray<NamiEntitlement *> * _Nonnull))activeEntitlementsHandler;
/// Clear any provisional entitlement grants, which are entitlements issued on-device only.
/// Useful for development and purchase testing. Not recommended to be called in production.
+ (void)clearProvisionalEntitlementGrants;
@end

typedef SWIFT_ENUM(NSInteger, NamiEntitlementType, open) {
  NamiEntitlementTypeOther = 0,
  NamiEntitlementTypeBinary_auth = 1,
  NamiEntitlementTypeQuota = 2,
  NamiEntitlementTypeConsumable = 3,
};

@class NSLocale;

/// Class that holds constant keys for language codes that Nami can accept for various languages.
SWIFT_CLASS("_TtC9NamiApple17NamiLanguageCodes")
@interface NamiLanguageCodes : NSObject
+ (NSString * _Nonnull)namiLanguageCodeFromLocale:(NSLocale * _Nonnull)locale SWIFT_WARN_UNUSED_RESULT;
/// All possible language codes accepted by Nami.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSSet<NSString *> * _Nonnull allAvailableNamiLanguageCodes;)
+ (NSSet<NSString *> * _Nonnull)allAvailableNamiLanguageCodes SWIFT_WARN_UNUSED_RESULT;
+ (void)setAllAvailableNamiLanguageCodes:(NSSet<NSString *> * _Nonnull)value;
/// Language Afrikaans
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull af;)
+ (NSString * _Nonnull)af SWIFT_WARN_UNUSED_RESULT;
/// Language Arabic
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ar;)
+ (NSString * _Nonnull)ar SWIFT_WARN_UNUSED_RESULT;
/// Language Algerian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ar_dz;)
+ (NSString * _Nonnull)ar_dz SWIFT_WARN_UNUSED_RESULT;
/// Language Asturian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ast;)
+ (NSString * _Nonnull)ast SWIFT_WARN_UNUSED_RESULT;
/// Language Azerbaijani
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull az;)
+ (NSString * _Nonnull)az SWIFT_WARN_UNUSED_RESULT;
/// Language Bulgarian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull bg;)
+ (NSString * _Nonnull)bg SWIFT_WARN_UNUSED_RESULT;
/// Language Belarusian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull be;)
+ (NSString * _Nonnull)be SWIFT_WARN_UNUSED_RESULT;
/// Language Bengali
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull bn;)
+ (NSString * _Nonnull)bn SWIFT_WARN_UNUSED_RESULT;
/// Language Breton
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull br;)
+ (NSString * _Nonnull)br SWIFT_WARN_UNUSED_RESULT;
/// Language Bosnian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull bs;)
+ (NSString * _Nonnull)bs SWIFT_WARN_UNUSED_RESULT;
/// Language Catalan
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ca;)
+ (NSString * _Nonnull)ca SWIFT_WARN_UNUSED_RESULT;
/// Language Czech
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull cs;)
+ (NSString * _Nonnull)cs SWIFT_WARN_UNUSED_RESULT;
/// Language Welsh
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull cy;)
+ (NSString * _Nonnull)cy SWIFT_WARN_UNUSED_RESULT;
/// Language Danish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull da;)
+ (NSString * _Nonnull)da SWIFT_WARN_UNUSED_RESULT;
/// Language German
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull de;)
+ (NSString * _Nonnull)de SWIFT_WARN_UNUSED_RESULT;
/// Language Lower Sorbian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull dsb;)
+ (NSString * _Nonnull)dsb SWIFT_WARN_UNUSED_RESULT;
/// Language Greek
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull el;)
+ (NSString * _Nonnull)el SWIFT_WARN_UNUSED_RESULT;
/// Language English
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull en;)
+ (NSString * _Nonnull)en SWIFT_WARN_UNUSED_RESULT;
/// Language Australian English
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull en_au;)
+ (NSString * _Nonnull)en_au SWIFT_WARN_UNUSED_RESULT;
/// Language British English
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull en_gb;)
+ (NSString * _Nonnull)en_gb SWIFT_WARN_UNUSED_RESULT;
/// Language Esperanto
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull eo;)
+ (NSString * _Nonnull)eo SWIFT_WARN_UNUSED_RESULT;
/// Language Spanish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull es;)
+ (NSString * _Nonnull)es SWIFT_WARN_UNUSED_RESULT;
/// Language Argentinian Spanish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull es_ar;)
+ (NSString * _Nonnull)es_ar SWIFT_WARN_UNUSED_RESULT;
/// Language Colombian Spanish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull es_co;)
+ (NSString * _Nonnull)es_co SWIFT_WARN_UNUSED_RESULT;
/// Language Mexican Spanish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull es_mx;)
+ (NSString * _Nonnull)es_mx SWIFT_WARN_UNUSED_RESULT;
/// Language Nicaraguan Spanish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull es_ni;)
+ (NSString * _Nonnull)es_ni SWIFT_WARN_UNUSED_RESULT;
/// Language Venezuelan Spanish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull es_ve;)
+ (NSString * _Nonnull)es_ve SWIFT_WARN_UNUSED_RESULT;
/// Language Estonian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull et;)
+ (NSString * _Nonnull)et SWIFT_WARN_UNUSED_RESULT;
/// Language Basque
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull eu;)
+ (NSString * _Nonnull)eu SWIFT_WARN_UNUSED_RESULT;
/// Language Persian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull fa;)
+ (NSString * _Nonnull)fa SWIFT_WARN_UNUSED_RESULT;
/// Language Finnish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull fi;)
+ (NSString * _Nonnull)fi SWIFT_WARN_UNUSED_RESULT;
/// Language French
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull fr;)
+ (NSString * _Nonnull)fr SWIFT_WARN_UNUSED_RESULT;
/// Language Frisian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull fy;)
+ (NSString * _Nonnull)fy SWIFT_WARN_UNUSED_RESULT;
/// Language Irish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ga;)
+ (NSString * _Nonnull)ga SWIFT_WARN_UNUSED_RESULT;
/// Language Scottish Gaelic
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull gd;)
+ (NSString * _Nonnull)gd SWIFT_WARN_UNUSED_RESULT;
/// Language Galician
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull gl;)
+ (NSString * _Nonnull)gl SWIFT_WARN_UNUSED_RESULT;
/// Language Hebrew
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull he;)
+ (NSString * _Nonnull)he SWIFT_WARN_UNUSED_RESULT;
/// Language Hindi
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull hi;)
+ (NSString * _Nonnull)hi SWIFT_WARN_UNUSED_RESULT;
/// Language Croatian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull hr;)
+ (NSString * _Nonnull)hr SWIFT_WARN_UNUSED_RESULT;
/// Language Upper Sorbian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull hsb;)
+ (NSString * _Nonnull)hsb SWIFT_WARN_UNUSED_RESULT;
/// Language Hungarian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull hu;)
+ (NSString * _Nonnull)hu SWIFT_WARN_UNUSED_RESULT;
/// Language Armenian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull hy;)
+ (NSString * _Nonnull)hy SWIFT_WARN_UNUSED_RESULT;
/// Language Interlingua
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ia;)
+ (NSString * _Nonnull)ia SWIFT_WARN_UNUSED_RESULT;
/// Language Indonesian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull id;)
+ (NSString * _Nonnull)id SWIFT_WARN_UNUSED_RESULT;
/// Language Igbo
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ig;)
+ (NSString * _Nonnull)ig SWIFT_WARN_UNUSED_RESULT;
/// Language Ido
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull io;)
+ (NSString * _Nonnull)io SWIFT_WARN_UNUSED_RESULT;
/// Language Icelandic
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull is_is;)
+ (NSString * _Nonnull)is_is SWIFT_WARN_UNUSED_RESULT;
/// Language Italian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull it;)
+ (NSString * _Nonnull)it SWIFT_WARN_UNUSED_RESULT;
/// Language Japanese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ja;)
+ (NSString * _Nonnull)ja SWIFT_WARN_UNUSED_RESULT;
/// Language Georgian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ka;)
+ (NSString * _Nonnull)ka SWIFT_WARN_UNUSED_RESULT;
/// Language Kabyle
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kab;)
+ (NSString * _Nonnull)kab SWIFT_WARN_UNUSED_RESULT;
/// Language Kazakh
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kk;)
+ (NSString * _Nonnull)kk SWIFT_WARN_UNUSED_RESULT;
/// Language Khmer
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull km;)
+ (NSString * _Nonnull)km SWIFT_WARN_UNUSED_RESULT;
/// Language Kannada
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kn;)
+ (NSString * _Nonnull)kn SWIFT_WARN_UNUSED_RESULT;
/// Language Korean
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ko;)
+ (NSString * _Nonnull)ko SWIFT_WARN_UNUSED_RESULT;
/// Language Kyrgyz
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ky;)
+ (NSString * _Nonnull)ky SWIFT_WARN_UNUSED_RESULT;
/// Language Luxembourgish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull lb;)
+ (NSString * _Nonnull)lb SWIFT_WARN_UNUSED_RESULT;
/// Language Lithuanian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull lt;)
+ (NSString * _Nonnull)lt SWIFT_WARN_UNUSED_RESULT;
/// Language Latvian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull lv;)
+ (NSString * _Nonnull)lv SWIFT_WARN_UNUSED_RESULT;
/// Language Macedonian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull mk;)
+ (NSString * _Nonnull)mk SWIFT_WARN_UNUSED_RESULT;
/// Language Malayalam
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ml;)
+ (NSString * _Nonnull)ml SWIFT_WARN_UNUSED_RESULT;
/// Language Mongolian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull mn;)
+ (NSString * _Nonnull)mn SWIFT_WARN_UNUSED_RESULT;
/// Language Marathi
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull mr;)
+ (NSString * _Nonnull)mr SWIFT_WARN_UNUSED_RESULT;
/// Language Burmese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull my;)
+ (NSString * _Nonnull)my SWIFT_WARN_UNUSED_RESULT;
/// Language Norwegian BokmÃ¥l
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull nb;)
+ (NSString * _Nonnull)nb SWIFT_WARN_UNUSED_RESULT;
/// Language Nepali
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ne;)
+ (NSString * _Nonnull)ne SWIFT_WARN_UNUSED_RESULT;
/// Language Dutch
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull nl;)
+ (NSString * _Nonnull)nl SWIFT_WARN_UNUSED_RESULT;
/// Language Norwegian Nynorsk
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull nn;)
+ (NSString * _Nonnull)nn SWIFT_WARN_UNUSED_RESULT;
/// Language Ossetic
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull os;)
+ (NSString * _Nonnull)os SWIFT_WARN_UNUSED_RESULT;
/// Language Punjabi
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull pa;)
+ (NSString * _Nonnull)pa SWIFT_WARN_UNUSED_RESULT;
/// Language Polish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull pl;)
+ (NSString * _Nonnull)pl SWIFT_WARN_UNUSED_RESULT;
/// Language Portuguese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull pt;)
+ (NSString * _Nonnull)pt SWIFT_WARN_UNUSED_RESULT;
/// Language Brazilian Portuguese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull pt_br;)
+ (NSString * _Nonnull)pt_br SWIFT_WARN_UNUSED_RESULT;
/// Language Romanian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ro;)
+ (NSString * _Nonnull)ro SWIFT_WARN_UNUSED_RESULT;
/// Language Russian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ru;)
+ (NSString * _Nonnull)ru SWIFT_WARN_UNUSED_RESULT;
/// Language Slovak
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sk;)
+ (NSString * _Nonnull)sk SWIFT_WARN_UNUSED_RESULT;
/// Language Slovenian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sl;)
+ (NSString * _Nonnull)sl SWIFT_WARN_UNUSED_RESULT;
/// Language Albanian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sq;)
+ (NSString * _Nonnull)sq SWIFT_WARN_UNUSED_RESULT;
/// Language Serbian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sr;)
+ (NSString * _Nonnull)sr SWIFT_WARN_UNUSED_RESULT;
/// Language Serbian Latin
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sr_latn;)
+ (NSString * _Nonnull)sr_latn SWIFT_WARN_UNUSED_RESULT;
/// Language Swedish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sv;)
+ (NSString * _Nonnull)sv SWIFT_WARN_UNUSED_RESULT;
/// Language Swahili
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sw;)
+ (NSString * _Nonnull)sw SWIFT_WARN_UNUSED_RESULT;
/// Language Tamil
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ta;)
+ (NSString * _Nonnull)ta SWIFT_WARN_UNUSED_RESULT;
/// Language Telugu
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull te;)
+ (NSString * _Nonnull)te SWIFT_WARN_UNUSED_RESULT;
/// Language Tajik
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull tg;)
+ (NSString * _Nonnull)tg SWIFT_WARN_UNUSED_RESULT;
/// Language Thai
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull th;)
+ (NSString * _Nonnull)th SWIFT_WARN_UNUSED_RESULT;
/// Language Turkmen
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull tk;)
+ (NSString * _Nonnull)tk SWIFT_WARN_UNUSED_RESULT;
/// Language Turkish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull tr;)
+ (NSString * _Nonnull)tr SWIFT_WARN_UNUSED_RESULT;
/// Language Tatar
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull tt;)
+ (NSString * _Nonnull)tt SWIFT_WARN_UNUSED_RESULT;
/// Language Udmurt
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull udm;)
+ (NSString * _Nonnull)udm SWIFT_WARN_UNUSED_RESULT;
/// Language Ukrainian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull uk;)
+ (NSString * _Nonnull)uk SWIFT_WARN_UNUSED_RESULT;
/// Language Urdu
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ur;)
+ (NSString * _Nonnull)ur SWIFT_WARN_UNUSED_RESULT;
/// Language Uzbek
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull uz;)
+ (NSString * _Nonnull)uz SWIFT_WARN_UNUSED_RESULT;
/// Language Vietnamese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull vi;)
+ (NSString * _Nonnull)vi SWIFT_WARN_UNUSED_RESULT;
/// Language Simplified Chinese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull zh_hans;)
+ (NSString * _Nonnull)zh_hans SWIFT_WARN_UNUSED_RESULT;
/// Language Traditional Chinese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull zh_hant;)
+ (NSString * _Nonnull)zh_hant SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Defiens various logging levels possible to see Nami SDK output - default is “error”, which means only erorrs will be displayed.  Set to “debug” to see as much logging as possible from the SDK.
typedef SWIFT_ENUM(NSInteger, NamiLogLevel, open) {
  NamiLogLevelError = 0,
  NamiLogLevelWarn = 1,
  NamiLogLevelInfo = 2,
  NamiLogLevelDebug = 3,
};

@class NSURLRequest;
@class NSHTTPURLResponse;
@class NSData;

/// Class to let an application be able to ingest logging messages from Nami.
SWIFT_PROTOCOL("_TtP9NamiApple16NamiLoggerClient_")
@protocol NamiLoggerClient <NSObject>
- (void)logHTTPWithRequest:(NSURLRequest * _Nonnull)request response:(NSHTTPURLResponse * _Nonnull)response responseData:(NSData * _Nullable)responseData message:(NSString * _Nonnull)message;
- (void)logMessage:(NSString * _Nonnull)message;
@end


SWIFT_CLASS("_TtC9NamiApple13NamiMLManager")
@interface NamiMLManager : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@interface NamiMLManager (SWIFT_EXTENSION(NamiApple))
/// Labeling method to help train the machine learning.  Use to identify important consumption patterns in your app that you believe drive customer loyalty.  Must be paired with a matching exitCoreContent call with the same label.  Use when your content has a natural hierarchy of tags such as [“images”, “clouds”, “cirrus”]
/// \param labels Set of keywords describing the section of the application entered.
///
+ (void)enterCoreContentWithLabels:(NSArray<NSString *> * _Nonnull)labels;
/// Labeling method to help train the machine learning.  Use to identify important consumption patterns in your app that you believe drive customer loyalty.  Must be paired with a matching exitCoreContent call with the same label.
/// \param label Keyword describing the portion of the app entered.  Machine learning will work best when using somewhat generic labels like “video” or “sports” rather than being very specific like “video_basketball_michael_jordan_dunk”.  Consult https://docs.namiml.com for best practices.
///
+ (void)enterCoreContentWithLabel:(NSString * _Nonnull)label;
/// Labeling method for training machine learning.  Called whenver the user exits a key part of your application.  Labels passed in should match labels passed into a corresponding enterCoreContentPath(labels:) call.
/// \param labels Keywords describing the portion of the app exited, matching labels passed in previously.
///
+ (void)exitCoreContentWithLabels:(NSArray<NSString *> * _Nonnull)labels;
/// Labeling method for training machine learning.  Called whenver the user exits a key part of your application.  Labels passed in should match labels passed into a corresponding enterCoreContent(labels:) call.
/// \param label Keyword describing the portion of the app exited, matching the label passed in previously.
///
+ (void)exitCoreContentWithLabel:(NSString * _Nonnull)label;
/// Labeling method for training machine learning.  Called whenver the user triggers some key action or event within your application.
/// \param label Keyword describing the action triggered by the user.
///
+ (void)coreActionWithLabel:(NSString * _Nonnull)label;
@end


SWIFT_CLASS("_TtC9NamiApple26NamiPaywallComponentChange")
@interface NamiPaywallComponentChange : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC9NamiApple16NamiPaywallEvent")
@interface NamiPaywallEvent : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC9NamiApple18NamiPaywallManager")
@interface NamiPaywallManager : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@class NamiPurchaseSuccess;
@class SKProduct;
@class SKPaymentTransaction;
@class NamiPromo;

@interface NamiPaywallManager (SWIFT_EXTENSION(NamiApple))
/// Provides Nami a callback to activate addiitonal UI required for the user to attempt to log in.  This is called when a paywall is raised that has a “sign in” button the user taps.
/// \param applicationSignInHandler A callback that wil be called at a time Nami is told a sign-in request has been made by a paywall.
///
+ (void)registerSignInHandler:(void (^ _Nullable)(UIViewController * _Nullable))applicationSignInHandler;
/// A hander invoked whenever a Nami paywall is closed.  This handler wil not be invoked for linked paywalls with your own UI.
/// \param paywallCloseHandler A callback that wil be called if a Nami paywall is being closed.
///
+ (void)registerCloseHandler:(void (^ _Nullable)(UIViewController * _Nullable))paywallCloseHandler;
/// Registers a callback that will be activated when user by taps on the Restore Purchases button on a Nami Paywall, so that the application
/// can process the request. This is for customers using Nami for paywalls, but not subscription management.
/// \param restoreRequestHandler A callback called when restore is requested by a user on the Nami Paywall
///
+ (void)registerRestoreRequestHandler:(void (^ _Nullable)(void))restoreRequestHandler SWIFT_DEPRECATED_MSG("", "registerRestoreHandler:");
/// Registers a callback that will be activated when user by taps on the Restore Purchases button on a Nami Paywall, so that the application
/// can process the request. This is for customers using Nami for paywalls, but not subscription management.
/// \param restoreHandler A callback called when restore is requested by a user on the Nami Paywall
///
+ (void)registerRestoreHandler:(void (^ _Nullable)(void))restoreHandler;
/// Registers an optional callback that will activate if a button on a paywall is setup to trigger a deeplink action.  By default, the SDK will dismiss the paywall
/// and open the deeplink via the operating system. If this handler is registered, it will be called instead so the app can implement custom logic.
/// \param deeplinkActionHandler A callback that wil be called at a time Nami is told a sign-in request has been made by a paywall.
///
+ (void)registerDeeplinkActionHandler:(void (^ _Nullable)(NSString * _Nonnull))deeplinkActionHandler;
/// Registers a callback that will be activated when a user triggers a buy sku action on a paywall.
/// Only available for plans where Nami is not handling subscription & IAP purchase management.
/// \param buySkuHandler A callback called when a buy sku action takes place
///
+ (void)registerBuySkuHandler:(void (^ _Nullable)(NamiSKU * _Nonnull))buySkuHandler;
/// Notify the NamiPaywallManager that an App Store in-app purchase handled by you is complete.
/// Only available for apps in which Nami is not handling subscription & IAP management.
/// \param purchaseSuccess A NamiPurchaseSuccess object for the purchase.
///
+ (void)buySkuCompleteWithPurchaseSuccess:(NamiPurchaseSuccess * _Nonnull)purchaseSuccess;
/// Notify the NamiPaywallManager that a StoreKit 2 purchase handled by you is complete.
/// Only available for apps in which Nami is not handling subscription & IAP management.
/// \param sku A <code>NamiSKU</code> object passed to you by <code>NamiPaywallBuySkuHandler</code>
///
/// \param product A StoreKit 1 <code>SKProduct</code> object used to make the purchase.
///
/// \param transaction A StoreKit 1 <code>SKPaymentTransaction</code> object for the purchase.
///
+ (void)buySkuCompleteWithSku:(NamiSKU * _Nonnull)sku product:(SKProduct * _Nonnull)product transaction:(SKPaymentTransaction * _Nonnull)transaction;
/// Notify the NamiPaywallManager that an App Store in-app purchase flow handled by you is cancelled.
/// Used to disable product purchase-in-progress loading indicators
+ (void)buySkuCancel;
/// Call in the case when you want to be sure a Nami paywall will have been closed
/// \param animated True for standard UIKit animation of dismissal, false otherwise.
///
/// \param completion Completion handler to be called when paywall is dismissed, may be immediate if not presented.
///
+ (void)dismissWithAnimated:(BOOL)animated completion:(void (^ _Nonnull)(void))completion;
/// Call to obtain a currently raised Nami Paywall view controller, will be .none if the paywall is closed.  Useful if you wish to present status alerts or other modal UI on top of a Nami paywall.
/// <ul>
///   <li>
///     Returns The view controller of a raised nami paywall, .none otherwise.
///   </li>
/// </ul>
+ (UIViewController * _Nullable)displayedViewController SWIFT_WARN_UNUSED_RESULT;
/// Used when a paywall is presented via a nami window to show the window if it’s currently hidden. Advanced use case.
+ (void)show;
/// Used when a paywall is presented via a nami window to find out if the paywall is currently hidden. Advanced use case.
+ (BOOL)isHidden SWIFT_WARN_UNUSED_RESULT;
/// Used when a paywall is presented via a nami window to hide the window if it’s currently showing. Advanced use case.
+ (void)hide;
/// Use this to check if a paywall is currently being shown to the end user
+ (BOOL)isPaywallOpen SWIFT_WARN_UNUSED_RESULT;
/// Receive a signed signature for applying to a promotion. Requires a proper entitlement to use.
+ (void)getSignedPromoWithSkuId:(NSString * _Nonnull)skuId promoId:(NSString * _Nonnull)promoId completeHandler:(void (^ _Nullable)(NamiPromo * _Nullable))completeHandler;
@end


SWIFT_CLASS("_TtC9NamiApple18NamiProductManager")
@interface NamiProductManager : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end




SWIFT_CLASS("_TtC9NamiApple9NamiPromo")
@interface NamiPromo : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSDate;
enum NamiPurchaseSource : NSInteger;

SWIFT_CLASS("_TtC9NamiApple12NamiPurchase")
@interface NamiPurchase : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull skuId;
@property (nonatomic, copy) NSString * _Nullable transactionIdentifier;
@property (nonatomic, copy) NSDate * _Nonnull purchaseInitiatedTimestamp;
@property (nonatomic, copy) NSDate * _Nullable expires;
@property (nonatomic) enum NamiPurchaseSource purchaseSource;
@property (nonatomic) NSInteger consumptionCount;
@property (nonatomic, readonly, copy) NSArray<NamiEntitlement *> * _Nonnull entitlementsGranted;
- (nonnull instancetype)initWithProductIdentifier:(NSString * _Nonnull)productIdentifier purchaseSource:(enum NamiPurchaseSource)purchaseSource OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) BOOL isSubscription;
@property (nonatomic, strong) NamiSKU * _Nullable sku;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum NamiPurchaseState : NSInteger;
enum NamiRestorePurchasesState : NSInteger;

/// Class to work with and manage purchases on the device.
SWIFT_CLASS("_TtC9NamiApple19NamiPurchaseManager")
@interface NamiPurchaseManager : NSObject
/// Checks to see if a SkuId (product app for Apple devices) has been purchased by the current device owner or not.
/// \param skuID ID of SKU you wish to check for purchase status
///
///
/// returns:
/// true if the SKU has been purchased, false otherwise.
+ (BOOL)skuPurchased:(NSString * _Nonnull)skuId SWIFT_WARN_UNUSED_RESULT;
/// Checks to see if any one of an array of SKUID (product app for Apple devices) has been purchased by the current device owner or not.
/// \param skuIDs Array of IDs of SKU you wish to check for purchase status
///
///
/// returns:
/// true if any SKU in the passed in array has been purchased, false otherwise.
+ (BOOL)anySkuPurchased:(NSArray<NSString *> * _Nonnull)skuIds SWIFT_WARN_UNUSED_RESULT;
/// Checks to see if a SKUID (product app for Apple devices) has been purchased, and returns the purchase record if found (holds things like purchase and expiration date if known).
/// \param skuID ID of SKU you wish to check for purchase status
///
///
/// returns:
/// NamiPurchase if found, .none otherwise.
+ (NamiPurchase * _Nullable)getRecordForSKU:(NSString * _Nonnull)skuId SWIFT_WARN_UNUSED_RESULT;
/// Takes in a set of SKUIDs (productIDs for Apple) and loads NamiSKU objects with StoreKIt and other metadata, so that you can examine product details or use for other calls.  If you pass in SKUIDs the system does not recognize, they will be returned as invalid and no NamiSKU objects will be returned for those IDs.
/// \param skuIDs ID of SKU you wish to check for purchase status
///
/// \param productHandler A callback to be given the loaded NamiSKU objects from the IDs you passed in, along with an array of invalid IDs the system could not load.
///
+ (void)skusForSKUIdsWithSkuIds:(NSArray<NSString *> * _Nonnull)skuIds productHandler:(void (^ _Nonnull)(BOOL, NSArray<NamiSKU *> * _Nullable, NSArray<NSString *> * _Nullable, NSError * _Nullable))productHandler;
/// Returns all known purchases for the current device.
///
/// returns:
/// NamiPurchase objects if any purchases are found, an empty array otherwise.
+ (NSArray<NamiPurchase *> * _Nonnull)allPurchases SWIFT_WARN_UNUSED_RESULT;
/// Registers a callback that will be activated when any purchase activity occurs - either purchases or expiration.
/// \param responseHandler A callback called when StoreKit purchase changes in the system are detected.
///
///
/// returns:
/// NamiPurchase objects if any purchases are found, an empty array otherwise.
+ (void)registerPurchasesChangedHandler:(void (^ _Nullable)(NSArray<NamiPurchase *> * _Nonnull, enum NamiPurchaseState, NSError * _Nullable))responseHandler;
/// Registers a callback that will be activated when any purchase activity occurs - either purchases or expiration.
/// \param changeHandler A callback called when StoreKit purchase changes in the system are detected.
///
///
/// returns:
/// NamiPurchase objects if any purchases are found, an empty array otherwise.
+ (void)registerWithPurchasesChangedHandler:(void (^ _Nullable)(NSArray<NamiPurchase *> * _Nonnull, enum NamiPurchaseState, NSError * _Nullable))changeHandler SWIFT_DEPRECATED_MSG("", "registerPurchasesChangedHandler:");
/// Registers a callback that will be activated when restore purchases in invoked (by tapping the Restore Purchases button on a Nami Paywall or by starting the restore purchases process directly), so that the application can react to the restore purchase process and potentially provide information in the UI about the restore process.
/// \param changeHandler A callback called when StoreKit restore purchases has been activated or finishes.
///
+ (void)registerRestorePurchasesHandlerWithRestorePurchasesStateHandler:(void (^ _Nullable)(enum NamiRestorePurchasesState, NSArray<NamiPurchase *> * _Nonnull, NSArray<NamiPurchase *> * _Nonnull, NSError * _Nullable))changeHandler;
/// Activates the system restore purchases feature, and calls back to a global <code>NamiRestorePurchasesStateHandler</code> handler with status if one is provided by
/// <code>registerRestorePurchasesHandler</code>. Restore replays all prior purchase transactions to determine which purchases are active.  This function trigger an app store password prompt if called, so only call this at the request of the user.  Generally this is not needed if your Nami account supports receipt validation, as the receipt is checked every time the app comes to the foreground and can determine active purchases that way.
+ (void)restorePurchases;
/// Activates the system restore purchases feature, and calls back to the provided <code>statehandler</code>.  Restore replays all prior purchase transactions to determine which purchases are active.  This function mau trigger an app store password prompt if called, so only call this at the request of the user.  Generally this is not needed if your Nami account supports receipt validation, as the receipt is checked every time the app comes to the foreground and can determine active purchases that way.
/// \param handler A callback called when the restore process is complete, with state indicators and all known purchases found.
///
+ (void)restorePurchasesWithStatehandler:(void (^ _Nonnull)(enum NamiRestorePurchasesState, NSArray<NamiPurchase *> * _Nonnull, NSArray<NamiPurchase *> * _Nonnull, NSError * _Nullable))statehandler;
/// Activates the system restore purchases feature, which replays all prior purchase transactions to determine which purchases are active.  This may trigger an app store password prompt if called, so only call this at the request of the user.  Generally this is not needed if your Nami account supports receipt validation, as the receipt is checked every time the app comes to the foreground and can determine active purchases that way.
/// \param handler A callback called when the restore process is complete, with success flag and errors (if any)
///
+ (void)restorePurchasesWithHandler:(void (^ _Nonnull)(BOOL, NSError * _Nullable))handler SWIFT_DEPRECATED;
/// For consumable purchases only, tells the system a purchase has been consumed - that is to say, your application has altered the application permanently to account for the purchase.  If you do not consume a consumable purchase, the purcahse will come back with every application launch.
/// \param skuID The ID (product ID for Apple) of the product you wish to consume - note that it must be purchased or this call will do nothing.
///
+ (void)consumePurchasedSkuWithSkuId:(NSString * _Nonnull)skuId;
/// Prompts iOS to show the system Subscription Offer Code redemption sheet, which the user can then enter a redemption code into.
/// Note that this call will do nothing on pre-ios14 devices, which do not implement that call and cannot redeem offer codes.
+ (void)presentCodeRedemptionSheet;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// The source a purchase comes from - either direct on the App Store, or through a paywall in-app controlled by a Nami campaign
typedef SWIFT_ENUM(NSInteger, NamiPurchaseSource, open) {
  NamiPurchaseSourceCampaign = 0,
  NamiPurchaseSourceMarketplace = 1,
  NamiPurchaseSourceUnknown = 2,
};

/// The various states a purcahse can be in depending on what is happening in StoreKit.
typedef SWIFT_ENUM(NSInteger, NamiPurchaseState, open) {
  NamiPurchaseStatePending = 0,
  NamiPurchaseStatePurchased = 1,
  NamiPurchaseStateConsumed = 2,
  NamiPurchaseStateResubscribed = 3,
  NamiPurchaseStateUnsubscribed = 4,
  NamiPurchaseStateDeferred = 5,
  NamiPurchaseStateFailed = 6,
  NamiPurchaseStateCancelled = 7,
  NamiPurchaseStateUnknown = 8,
};


SWIFT_CLASS("_TtC9NamiApple19NamiPurchaseSuccess")
@interface NamiPurchaseSuccess : NSObject
- (nonnull instancetype)initWithProduct:(NamiSKU * _Nonnull)product transactionID:(NSString * _Nonnull)transactionID originalTransactionID:(NSString * _Nonnull)originalTransactionID price:(NSDecimal)price currencyCode:(NSString * _Nonnull)currencyCode OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Wimple wrapper around IAP JSON from an Apple parsed StoreKit receipt.  Note you can always get the original IAP product dict from the parsed receipt via the iapJSONDict property.
SWIFT_CLASS("_TtC9NamiApple21NamiReceiptIAPWrapper")
@interface NamiReceiptIAPWrapper : NSObject
/// The orignal JSON values from the Apple receipt data.
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull iapJSONDict;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum StoreKitEnvironmentObjC : NSInteger;

SWIFT_CLASS("_TtC9NamiApple18NamiReceiptWrapper")
@interface NamiReceiptWrapper : NSObject
/// The raw JSON data returned from Apple processing the receipt data sent from your device.
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull receiptJSONDict;
/// Lets you know if there’s any receupt data to lok at, in cases of varous errors or passive mode, you’ll not have receipt data from a validation call.
@property (nonatomic, readonly) BOOL hasReceiptData;
/// Lets you know if the error messages mean your shared secret may not be set correctly.
@property (nonatomic, readonly) BOOL possibleReceiptSharedSecretIssue;
/// The status code for this attempt at receipt validation.
@property (nonatomic, readonly) NSInteger statusCode;
/// The current StoreKit environment, for objective C.
@property (nonatomic, readonly) enum StoreKitEnvironmentObjC storeKitEnvironmentObjC;
/// The original application version when the user first purchased/downloaded your application, so you know when they started using your application.
- (NSString * _Nullable)originalApplicationVersion SWIFT_WARN_UNUSED_RESULT;
/// Full iAP receipt dictionary values.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)fullIAPReceiptInfoDict SWIFT_WARN_UNUSED_RESULT;
/// Latest receipt dictionary values.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)latestReceiptInfoDict SWIFT_WARN_UNUSED_RESULT;
/// Latest receipt dictionary values.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)inAppItems SWIFT_WARN_UNUSED_RESULT;
/// All of the IAP items from the receipt, sorted by date so the newest onese are on top.
- (NSArray<NamiReceiptIAPWrapper *> * _Nonnull)sortedIAPItemsFromDate:(NSDate * _Nonnull)fromDate SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, NamiRestorePurchasesState, open) {
  NamiRestorePurchasesStateStarted = 0,
  NamiRestorePurchasesStateFinished = 1,
  NamiRestorePurchasesStateError = 2,
};

enum NamiSKUType : NSInteger;

/// Object that is an abstraction of the products setup in App Store Connect as per the products section of the Nami Control Center.
SWIFT_CLASS("_TtC9NamiApple7NamiSKU")
@interface NamiSKU : NSObject
/// Internal Nami identifier for the product, exposed to conform to the Identifiable protocol so a list of NamiSKUs can be used easily in SwiftUI inside of a ForEach, etc.
@property (nonatomic, copy) NSString * _Nonnull id;
/// The Platform speciifc ID, or productIdentifier for Apple platforms.
@property (nonatomic, copy) NSString * _Nonnull skuId;
/// Reference Name field for this product in the Nami Control Center
@property (nonatomic, copy) NSString * _Nullable name;
/// Type of product -  <code>subscription</code> or  <code>one_time_purchase</code>.
@property (nonatomic) enum NamiSKUType type;
/// Any entitlements this product is associated with in the Nami Control Center
@property (nonatomic, copy) NSArray<NamiEntitlement *> * _Nonnull associatedEntitlements;
/// The App Store promo ID if provided
@property (nonatomic, copy) NSString * _Nullable promoId;
/// If available, the local system object for this product.  For SKU types not of the current platform, this will always be empty.
@property (nonatomic) id _Nullable product;
- (nonnull instancetype)initWithNamiId:(NSString * _Nonnull)namiId storeId:(NSString * _Nonnull)storeId skuType:(enum NamiSKUType)skuType OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The possible types of products for Apple devices - either one time purchase (consumable/nonconsumable) or subscription.
typedef SWIFT_ENUM(NSInteger, NamiSKUType, open) {
  NamiSKUTypeUnknown = 0,
  NamiSKUTypeOne_time_purchase = 1,
  NamiSKUTypeSubscription = 2,
};


/// Class to help with some aspects of direct StoreKit access.
SWIFT_CLASS("_TtC9NamiApple18NamiStoreKitHelper")
@interface NamiStoreKitHelper : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NamiStoreKitHelper * _Nonnull shared;)
+ (NamiStoreKitHelper * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Identifier for times when the system needs to return a namiSKU, but there’s no real product behind that wrapper.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull noProductIdentifier;)
+ (NSString * _Nonnull)noProductIdentifier SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull objCStoreKitEnvironment;
/// Verifies any already local receipt the app may have by sending the receipt data to the Nami server, which calls Apple for the most recent receipt data.
- (void)verifyReceiptWithCompletion:(void (^ _Nonnull)(NamiReceiptWrapper * _Nullable))completion;
/// Last app receipt json obtained, if any.
+ (NamiReceiptWrapper * _Nullable)appReceipt SWIFT_WARN_UNUSED_RESULT;
@end



SWIFT_CLASS("_TtC9NamiApple20PaywallLaunchContext")
@interface PaywallLaunchContext : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface SKProduct (SWIFT_EXTENSION(NamiApple))
/// Builds a simple dictionary for a product that holds price, locale, and currency values for this product.
- (NSDictionary<NSString *, id> * _Nonnull)namiInfoDict SWIFT_WARN_UNUSED_RESULT;
- (NSDictionary<NSString *, id> * _Nonnull)namiInfoDictWithPurchaseSource:(enum NamiPurchaseSource)_ SWIFT_WARN_UNUSED_RESULT;
@end



/// This enum represents the possible time units for adjusting simulated sandbox acceleration - the reduction of real-world time into smaller units for testing purposes when bypassStore is enabled.
typedef SWIFT_ENUM(NSInteger, SandboxAccelerationItemUnit, open) {
  SandboxAccelerationItemUnitHour = 0,
  SandboxAccelerationItemUnitWeek = 1,
  SandboxAccelerationItemUnitMonth = 2,
  SandboxAccelerationItemUnitSixMonth = 3,
  SandboxAccelerationItemUnitYear = 4,
};

/// Objective-C enum for store kit environments as there are no String enums in Objective-C.
typedef SWIFT_ENUM(NSInteger, StoreKitEnvironmentObjC, open) {
  StoreKitEnvironmentObjCProduction = 0,
  StoreKitEnvironmentObjCSandbox = 1,
  StoreKitEnvironmentObjCNamiStoreKitBypass = 2,
  StoreKitEnvironmentObjCEnvironmentNotYetDetected = 3,
};


SWIFT_CLASS("_TtC9NamiApple19StoreKitQueueHelper")
@interface StoreKitQueueHelper : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Possuble status codes from StoreKit.  The msot likley one to be seen is 21004, which measns Nami does not have the shared sescret it needs to send your receipts to Apple.  Add in the Nami Control Center developer tab.
typedef SWIFT_ENUM(NSInteger, StoreKitStatusCodes, open) {
  StoreKitStatusCodesStatusOK = 0,
  StoreKitStatusCodesUnreadableJSON = 21000,
  StoreKitStatusCodesReceiptMalformed = 21002,
  StoreKitStatusCodesReceiptAuthFailed = 21003,
  StoreKitStatusCodesSharedSecretInvalid = 21004,
  StoreKitStatusCodesReceiptServerUnavailable = 21005,
  StoreKitStatusCodesSubscriptionExpired = 21006,
  StoreKitStatusCodesReceiptFromSandboxEnvironment = 21007,
  StoreKitStatusCodesReceiptFromProdEnvironent = 21008,
  StoreKitStatusCodesNamiError = 99999,
};







#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
#ifndef NAMIAPPLE_SWIFT_H
#define NAMIAPPLE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import StoreKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="NamiApple",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

typedef SWIFT_ENUM(NSInteger, AccountStateAction, open) {
  AccountStateActionLogin = 0,
  AccountStateActionLogout = 1,
  AccountStateActionAdvertising_id_set = 2,
  AccountStateActionAdvertising_id_cleared = 3,
  AccountStateActionVendor_id_set = 4,
  AccountStateActionVendor_id_cleared = 5,
  AccountStateActionCustomer_data_platform_id_set = 6,
  AccountStateActionCustomer_data_platform_id_cleared = 7,
  AccountStateActionAnonymous_mode_on = 8,
  AccountStateActionAnonymous_mode_off = 9,
  AccountStateActionNami_device_id_set = 10,
  AccountStateActionNami_device_id_cleared = 11,
};

@class NSNumber;
@class NSCoder;

SWIFT_CLASS("_TtC9NamiApple20CustomerJourneyState")
@interface CustomerJourneyState : NSObject <NSCoding>
@property (nonatomic, readonly) BOOL formerSubscriber;
@property (nonatomic, readonly) BOOL inGracePeriod;
@property (nonatomic, readonly) BOOL inTrialPeriod;
@property (nonatomic, readonly) BOOL inIntroOfferPeriod;
@property (nonatomic, readonly) BOOL isCancelled;
@property (nonatomic, readonly) BOOL inPause;
@property (nonatomic, readonly) BOOL inAccountHold;
- (nonnull instancetype)initWithFormerSubscriber:(BOOL)formerSubscriber inGracePeriod:(BOOL)inGracePeriod inTrialPeriod:(BOOL)inTrialPeriod inIntroOfferPeriod:(BOOL)inIntroOfferPeriod isCancelled:(BOOL)isCancelled inPause:(BOOL)inPause inAccountHold:(BOOL)inAccountHold OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
@end



SWIFT_CLASS("_TtC9NamiApple12ImageService")
@interface ImageService : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




/// Possible campaign errors from the launch call.
typedef SWIFT_ENUM(NSInteger, LaunchCampaignError, open) {
  LaunchCampaignErrorDEFAULT_CAMPAIGN_NOT_FOUND = 0,
  LaunchCampaignErrorLABELED_CAMPAIGN_NOT_FOUND = 1,
  LaunchCampaignErrorCAMPAIGN_DATA_NOT_FOUND = 2,
  LaunchCampaignErrorPAYWALL_ALREADY_DISPLAYED = 3,
  LaunchCampaignErrorSDK_NOT_INITIALIZED = 4,
  LaunchCampaignErrorPAYWALL_COULD_NOT_DISPLAY = 5,
  LaunchCampaignErrorURL_CAMPAIGN_NOT_FOUND = 6,
  LaunchCampaignErrorPRODUCT_DATA_NOT_FOUND = 7,
  LaunchCampaignErrorPRODUCT_GROUPS_NOT_FOUND = 8,
};




/// This is the core Nami class, that handles central configuration across the Nami SDK
SWIFT_CLASS("_TtC9NamiApple4Nami")
@interface Nami : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) Nami * _Nonnull shared;)
+ (Nami * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NamiConfiguration;
enum NamiConfigureState : NSInteger;
enum NamiLogLevel : NSInteger;

@interface Nami (SWIFT_EXTENSION(NamiApple))
/// This is the initial call that activates the Nami SDK, it should be called as soon as possible within your app (preferably first in ApplicationDidFinishLaunching).
/// It is passed a configuration object that  defines at a minimum the App Platform ID Nami should use, but also other adjustments to how Nami should operate.
/// \param namiConfig NamiConfiguration object instance with appPlatformID set to value defined for this app in the Control Center.
///
+ (void)configureWith:(NamiConfiguration * _Nonnull)namiConfig :(void (^ _Nullable)(BOOL))sdkInitHandler;
/// This is the initial call that activates the Nami SDK, it should be called as soon as possible within your app (preferably first in ApplicationDidFinishLaunching).
/// It is passed a configuration object that  defines at a minimum the App Platform ID Nami should use, but also other adjustments to how Nami should operate.
/// \param namiConfig NamiConfiguration object instance with appPlatformID set to value defined for this app in the Control Center.
/// If called again during runtime, this method will evaluate what changes to the previous configuration occured and react accordingly.
///
+ (void)configureWithConfig:(NamiConfiguration * _Nonnull)namiConfig :(void (^ _Nullable)(BOOL, enum NamiConfigureState))sdkInitStateHandler;
/// Allows for dynamic re-adjustment of SDK log level if desired, from the log level set in the <code>NamiConfiguration</code> object.
/// \param logLevel New log level you wish to set, same as the log levels that can be set in the Nami.configure() call.
///
+ (void)setLogLevel:(enum NamiLogLevel)logLevel;
+ (BOOL)namiWindowEnabled SWIFT_WARN_UNUSED_RESULT;
/// Returns whether or not Nami is responsible for purchase management based upon the Nami account’s organization settings.
+ (BOOL)isPurchaseManagementEnabled SWIFT_WARN_UNUSED_RESULT;
+ (BOOL)sdkConfigured SWIFT_WARN_UNUSED_RESULT;
@end

@class NSString;

SWIFT_CLASS("_TtC9NamiApple12NamiCampaign")
@interface NamiCampaign : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
@property (nonatomic, copy) NSString * _Nonnull rule;
@property (nonatomic, copy) NSString * _Nonnull segment;
@property (nonatomic, copy) NSString * _Nonnull paywall;
@property (nonatomic, copy) NSString * _Nullable value;
@property (nonatomic, copy) NSString * _Nullable external_segment;
@property (nonatomic, copy) NSString * _Nullable name;
@end

@class NSURL;

SWIFT_CLASS("_TtC9NamiApple19NamiCampaignManager")
@interface NamiCampaignManager : NSObject
- (void)registerWithAvailableCampaignsHandler:(void (^ _Nullable)(NSArray<NamiCampaign *> * _Nonnull))availableCampaignsHandler;
/// Unregisters any active entilement change handlers..
+ (void)unregisterAvailableCampaignsHandler;
/// Registers a callback that will be activated when campaigns are loaded from cache or fetched from the Nami service.
/// \param availableCampaignsHandler A callback called when campaigns for this device are made available.
///
+ (void)registerAvailableCampaignsHandler:(void (^ _Nonnull)(NSArray<NamiCampaign *> * _Nonnull))availableCampaignsHandler;
/// Receive a list of all live campaigns sent to this device by the Nami service.
+ (NSArray<NamiCampaign *> * _Nonnull)allCampaigns SWIFT_WARN_UNUSED_RESULT;
/// Return true if a campaign with the supplied label is available on the device for launch
+ (BOOL)isCampaignAvailableWithLabel:(NSString * _Nonnull)label SWIFT_WARN_UNUSED_RESULT;
/// Return true if a campaign with the supplied label is available on the device for launch
+ (BOOL)isCampaignAvailableWithUrl:(NSURL * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// Return true if a campaign without a  label is available on the device for launch
+ (BOOL)isCampaignAvailable SWIFT_WARN_UNUSED_RESULT;
/// Asks Nami to update internal entitlements, if an action has been taken you feel might have affected entitlements recently and you would like to check.
+ (void)refresh;
/// Asks Nami to update internal entitlements, if an action has been taken you feel might have affected entitlements recently and you would like to check.
/// \param refreshHandler Called when the entitlement check has returned from Nami and system entitlments updated.
///
+ (void)refresh:(void (^ _Nullable)(NSArray<NamiCampaign *> * _Nonnull))refreshHandler;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PaywallLaunchContext;
@class NamiPaywallEvent;
@class UIViewController;

@interface NamiCampaignManager (SWIFT_EXTENSION(NamiApple))
/// Presents a paywall for the default campaign.
+ (void)launch;
/// Presents a paywall for a campain with a specific campaign label.
/// \param label Campaign label defined in Nami Control Center for launching a specific campaign.
///
+ (void)launchWithLabel:(NSString * _Nonnull)label;
/// Presents a paywall for a campaign with the selection of the paywall and paywall loading affected by the parameters passed in as listed below.
/// \param label Campaign label defined in Nami Control Center for launching a specific campaign.
///
/// \param launchHandler Handler to be invoked on success or if campaign cannot be launched due to an error.
///
/// \param paywallActionHandler Handler to be invoked when a paywall action occurs during this launch.
///
+ (void)launchWithLabel:(NSString * _Nullable)label context:(PaywallLaunchContext * _Nullable)context launchHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))launchHandler paywallActionHandler:(void (^ _Nullable)(NamiPaywallEvent * _Nonnull))paywallActionHandler;
/// Presents a paywall for a campaign with the selection of the paywall and paywall loading affected by the parameters passed in as listed below.
/// \param label Campaign label defined in Nami Control Center for launching a specific campaign.
///
/// \param viewController Optional provided view controller to present the paywall from.
///
/// \param context Optional PaywallLaunchContext which is used to contextual certain paywall templates.
///
/// \param launchHandler Handler to be invoked on success or if campaign cannot be launched due to an error.
///
/// \param paywallActionHandler Handler to be invoked when a paywall action occurs during this launch.
///
+ (void)launchWithLabel:(NSString * _Nullable)label viewController:(UIViewController * _Nullable)viewController context:(PaywallLaunchContext * _Nullable)context launchHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))launchHandler paywallActionHandler:(void (^ _Nullable)(NamiPaywallEvent * _Nonnull))paywallActionHandler;
/// Presents a paywall for a campaign with the selection of the paywall and paywall loading affected by the url passed in as listed below.
/// \param url Campaign url defined in Nami Control Center for launching a specific campaign.
///
/// \param viewController Optional provided view controller to present the paywall from.
///
/// \param context Optional PaywallLaunchContext which is used to contextual certain paywall templates.
///
/// \param launchHandler Handler to be invoked on success or if campaign cannot be launched due to an error.
///
/// \param paywallActionHandler Handler to be invoked when a paywall action occurs during this launch.
///
+ (void)launchWithUrl:(NSURL * _Nonnull)url viewController:(UIViewController * _Nullable)viewController context:(PaywallLaunchContext * _Nullable)context launchHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))launchHandler paywallActionHandler:(void (^ _Nullable)(NamiPaywallEvent * _Nonnull))paywallActionHandler;
@end


/// Configuration object to use with the Nami.configure() call.
SWIFT_CLASS("_TtC9NamiApple17NamiConfiguration")
@interface NamiConfiguration : NSObject
/// Alternate form of constructing a NamiConfiguration object, primarily used by ObjectiveC clients that cannot access the initializer.
/// \param appPlatformID The App Platform  ID for this app, obtained from the Control Center App Settings screen.
///
+ (NamiConfiguration * _Nonnull)configurationForAppPlatformId:(NSString * _Nonnull)appPlatformId SWIFT_WARN_UNUSED_RESULT;
/// The Nami App Platform ID to use for this app.
@property (nonatomic, readonly, copy) NSString * _Nonnull appPlatformId;
/// Defines what level of logging output that is desired from the Nami SDK.  Default is error.
@property (nonatomic) enum NamiLogLevel logLevel;
/// Declares the language of the desired configuration from the server, set from the possible set of values defined in NamiLanguageCodes.
@property (nonatomic, copy) NSString * _Nonnull namiLanguageCode;
/// Initial configuration used to help bootstrap the SDK on first run. Retrieve the intial config JSON file from
/// the Nami Control Center. Read in the JSON file as Data and pass the Data here.
@property (nonatomic, copy) NSString * _Nullable initialConfig;
/// Override the default behavior for how long a provisional entitlement grant will be valid before it expires.
/// If not provided, production purchases will grant a provisional entitlement for 24 hours. All other
/// purchases will grant for 3 minutes.
/// Override values need to be provided in seconds.
@property (nonatomic) double provisionalGrantTTL;
/// For customers using a custom instance of Nami with a unique hostname
@property (nonatomic, copy) NSString * _Nullable customHostname;
/// Used to activate internal features of the SDK not generally used by Nami customers.
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull namiCommands;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, NamiConfigureState, open) {
  NamiConfigureStateInitial_success = 0,
  NamiConfigureStateReconfig_success = 1,
  NamiConfigureStateAlready_configured = 2,
  NamiConfigureStateNot_configured = 3,
};


SWIFT_CLASS("_TtC9NamiApple19NamiCustomerManager")
@interface NamiCustomerManager : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSUUID;

@interface NamiCustomerManager (SWIFT_EXTENSION(NamiApple))
/// Reutrrns the set of current customer journey states.
///
/// returns:
/// An object continating various custoemr journey state items.
+ (CustomerJourneyState * _Nullable)journeyState SWIFT_WARN_UNUSED_RESULT;
/// Registers a callback that will be activated when any customer journey activity occurs
/// \param journeyStateHandler A callback called when customer journey changes in the system are detected.
///
+ (void)registerJourneyStateHandler:(void (^ _Nullable)(CustomerJourneyState * _Nonnull))journeyStateHandler;
/// Registers a callback that will be activated when any account state changes occur.
/// \param accountStateHandler A callback called when account state changes, or attempted changes, are detected.
///
+ (void)registerAccountStateHandler:(void (^ _Nullable)(enum AccountStateAction, BOOL, NSError * _Nullable))accountStateHandler;
/// Inform Nami about your app account ID used to log in a user.  Must be a SHA256 hash or UUID.  Will link this device to others that share the same app account.
/// \param withId A SHA256 hash or UUID you generate that identifies the app account for the user.
///
+ (void)loginWithId:(NSString * _Nonnull)id loginCompleteHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))loginCompleteHandler;
/// Returns <code>true</code> if any user is currently logged in to nami for this device.
+ (BOOL)isLoggedIn SWIFT_WARN_UNUSED_RESULT;
/// Returns the currently defined app account identifier for the device.
+ (NSString * _Nullable)loggedInId SWIFT_WARN_UNUSED_RESULT;
/// Logs the user out and clears the app account ID.
+ (void)logoutWithLogoutCompleteHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))logoutCompleteHandler;
/// Uniquie identifier used by Nami to identify this device. Please note, this value does not persist across app re-installs.
+ (NSString * _Nonnull)deviceId SWIFT_WARN_UNUSED_RESULT;
/// Allows users to opt-out of sending device-level data to the Nami service. Opted-in by default unless explicitly opted out.
/// <ul>
///   <li>
///     : anonymousMode:  A boolean that is true if the device has opted-out of device-level data.
///   </li>
/// </ul>
+ (void)setAnonymousMode:(BOOL)anonymousMode;
/// Returns whether or not the SDK is currently operating in anonymous mode
+ (BOOL)inAnonymousMode SWIFT_WARN_UNUSED_RESULT;
/// Returns whether or not this app platform id belongs to an anonymous mode capable Nami account.
+ (BOOL)anonymousModeCapability SWIFT_WARN_UNUSED_RESULT;
/// Allows you to pass the system Vendor ID to Nami
/// \param vendorId Advertising Identifier obtained from the system or your own custom UUID.
///
+ (void)setVendorIdWith:(NSUUID * _Nonnull)vendorId;
/// Clear a Vendor ID that has been sent to Nami
+ (void)clearVendorId;
/// Allows you to pass the system Advertising Identifier to Nami
/// \param advertisingId Advertising Identifier obtained from the system or your own custom UUID.
///
+ (void)setAdvertisingIdWith:(NSUUID * _Nonnull)advertisingId;
/// Clear a Advertising Identifier that has been sent to Nami
+ (void)clearAdvertisingId;
/// Allows you to pass your CDP Identifier to Nami
/// \param cdpId Identifier obtained from your Customer Data Platform.
///
+ (void)setCustomerDataPlatformIdWith:(NSString * _Nonnull)cdpId;
/// Clear a CDP Identifier that has been sent to Nami
+ (void)clearCustomerDataPlatformId;
/// Customer attributes are optional key/value pairs that can be used to personalize your Nami paywalls.
/// \param key The name of the attribute. For example: <code>firstName</code> or <code>favoriteTeam</code>
///
/// \param value The value of the attribute. For example: <code>Joe</code> or <code>Arsenal F.C.</code>
///
+ (void)setCustomerAttribute:(NSString * _Nonnull)key :(NSString * _Nonnull)value;
/// Clear a value  for a given key in the on-device customer attribute key/value store.
/// \param key The name of the attribute. For example: <code>firstName</code>
///
+ (void)clearCustomerAttribute:(NSString * _Nonnull)key;
/// Clear all customer attributes from the on-device key/value store.
+ (void)clearAllCustomerAttributes;
/// Get a value  for a given key in the on-device customer attribute key/value store.
/// \param key The name of the attribute. For example: <code>firstName</code>
///
+ (NSString * _Nullable)getCustomerAttributeWithKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
@end

@class NamiSKU;
@class NamiPurchase;

/// Entitlements grant access to features, content, or other aspects of your app.  Manage your entitlements in the Nami Control Center. Entitlements are associated with Product SKUs which are the specific in-app purchase products that grant an entitlement.
SWIFT_CLASS("_TtC9NamiApple15NamiEntitlement")
@interface NamiEntitlement : NSObject
/// Developer friendly name of entitlement
@property (nonatomic, copy) NSString * _Nullable name;
/// Description of entitlement
@property (nonatomic, copy) NSString * _Nullable desc;
/// The unique ID of the entitlement, use this to refer to the system when referencing an entitlements.
@property (nonatomic, copy) NSString * _Nonnull referenceId;
/// All SKU’s (StoreKit products or other) that grant this entitlement on purchase on this app platform.
@property (nonatomic, readonly, copy) NSArray<NamiSKU *> * _Nonnull relatedSkus;
/// List of NamiSKU objects that have been purchased and grant this entitlement.
@property (nonatomic, readonly, copy) NSArray<NamiSKU *> * _Nonnull purchasedSkus;
/// Purchase records for any purchased SKU.  Purchase records hold details like date of purchase, or subscription expiration.
@property (nonatomic, readonly, copy) NSArray<NamiPurchase *> * _Nonnull activePurchases;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC9NamiApple22NamiEntitlementManager")
@interface NamiEntitlementManager : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)registerWithActiveEntitlementsHandler:(void (^ _Nullable)(NSArray<NamiEntitlement *> * _Nonnull))activeEntitlementsHandler;
@end


@interface NamiEntitlementManager (SWIFT_EXTENSION(NamiApple))
/// Returns a list of all entitlements defined in the Control Center.  Note this includes both inactive and active entitlements. To see only active entitements use activeEntitlements().
///
/// returns:
/// array of all NamiEntitlements objects defined in the Control Center
+ (NSArray<NamiEntitlement *> * _Nonnull)available SWIFT_WARN_UNUSED_RESULT;
/// Returns a list of all active entitlements.  Nami checks entitlements across all platforms you have set up in the Control Center.  Use active entitlements to control access to different features in your app.
///
/// returns:
/// list of active NamiEntitlement objects.
+ (NSArray<NamiEntitlement *> * _Nonnull)active SWIFT_WARN_UNUSED_RESULT;
/// Check if a specific entitlement ID is active.
/// \param referenceID Entitlement ID to check.  Defined in the Control Center.
///
///
/// returns:
/// true if the entitlement matching the passed in ID is active, false otherwise.
+ (BOOL)isEntitlementActive:(NSString * _Nonnull)referenceId SWIFT_WARN_UNUSED_RESULT;
/// Asks Nami to update internal entitlements, if an action has been taken you feel might have affected entitlements recently and you would like to check.
+ (void)refresh;
/// Asks Nami to update internal entitlements, if an action has been taken you feel might have affected entitlements recently and you would like to check.
/// \param refreshHandler Called when the entitlement check has returned from Nami and system entitlments updated.
///
+ (void)refresh:(void (^ _Nullable)(NSArray<NamiEntitlement *> * _Nonnull))refreshHandler;
/// Unregisters any active entilement change handlers..
+ (void)unregisterActiveEntitlementsHandler;
/// Registers a callback that will be activated when any entitlement activity occurs - either added or removed.
/// \param changeHandler A callback called when entitlement changes in the system are detected.
///
+ (void)registerActiveEntitlementsHandler:(void (^ _Nonnull)(NSArray<NamiEntitlement *> * _Nonnull))activeEntitlementsHandler;
/// Clear any provisional entitlement grants, which are entitlements issued on-device only.
/// Useful for development and purchase testing. Not recommended to be called in production.
+ (void)clearProvisionalEntitlementGrants;
@end

typedef SWIFT_ENUM(NSInteger, NamiEntitlementType, open) {
  NamiEntitlementTypeOther = 0,
  NamiEntitlementTypeBinary_auth = 1,
  NamiEntitlementTypeQuota = 2,
  NamiEntitlementTypeConsumable = 3,
};

@class NSLocale;

/// Class that holds constant keys for language codes that Nami can accept for various languages.
SWIFT_CLASS("_TtC9NamiApple17NamiLanguageCodes")
@interface NamiLanguageCodes : NSObject
+ (NSString * _Nonnull)namiLanguageCodeFromLocale:(NSLocale * _Nonnull)locale SWIFT_WARN_UNUSED_RESULT;
/// All possible language codes accepted by Nami.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSSet<NSString *> * _Nonnull allAvailableNamiLanguageCodes;)
+ (NSSet<NSString *> * _Nonnull)allAvailableNamiLanguageCodes SWIFT_WARN_UNUSED_RESULT;
+ (void)setAllAvailableNamiLanguageCodes:(NSSet<NSString *> * _Nonnull)value;
/// Language Afrikaans
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull af;)
+ (NSString * _Nonnull)af SWIFT_WARN_UNUSED_RESULT;
/// Language Arabic
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ar;)
+ (NSString * _Nonnull)ar SWIFT_WARN_UNUSED_RESULT;
/// Language Algerian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ar_dz;)
+ (NSString * _Nonnull)ar_dz SWIFT_WARN_UNUSED_RESULT;
/// Language Asturian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ast;)
+ (NSString * _Nonnull)ast SWIFT_WARN_UNUSED_RESULT;
/// Language Azerbaijani
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull az;)
+ (NSString * _Nonnull)az SWIFT_WARN_UNUSED_RESULT;
/// Language Bulgarian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull bg;)
+ (NSString * _Nonnull)bg SWIFT_WARN_UNUSED_RESULT;
/// Language Belarusian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull be;)
+ (NSString * _Nonnull)be SWIFT_WARN_UNUSED_RESULT;
/// Language Bengali
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull bn;)
+ (NSString * _Nonnull)bn SWIFT_WARN_UNUSED_RESULT;
/// Language Breton
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull br;)
+ (NSString * _Nonnull)br SWIFT_WARN_UNUSED_RESULT;
/// Language Bosnian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull bs;)
+ (NSString * _Nonnull)bs SWIFT_WARN_UNUSED_RESULT;
/// Language Catalan
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ca;)
+ (NSString * _Nonnull)ca SWIFT_WARN_UNUSED_RESULT;
/// Language Czech
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull cs;)
+ (NSString * _Nonnull)cs SWIFT_WARN_UNUSED_RESULT;
/// Language Welsh
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull cy;)
+ (NSString * _Nonnull)cy SWIFT_WARN_UNUSED_RESULT;
/// Language Danish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull da;)
+ (NSString * _Nonnull)da SWIFT_WARN_UNUSED_RESULT;
/// Language German
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull de;)
+ (NSString * _Nonnull)de SWIFT_WARN_UNUSED_RESULT;
/// Language Lower Sorbian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull dsb;)
+ (NSString * _Nonnull)dsb SWIFT_WARN_UNUSED_RESULT;
/// Language Greek
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull el;)
+ (NSString * _Nonnull)el SWIFT_WARN_UNUSED_RESULT;
/// Language English
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull en;)
+ (NSString * _Nonnull)en SWIFT_WARN_UNUSED_RESULT;
/// Language Australian English
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull en_au;)
+ (NSString * _Nonnull)en_au SWIFT_WARN_UNUSED_RESULT;
/// Language British English
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull en_gb;)
+ (NSString * _Nonnull)en_gb SWIFT_WARN_UNUSED_RESULT;
/// Language Esperanto
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull eo;)
+ (NSString * _Nonnull)eo SWIFT_WARN_UNUSED_RESULT;
/// Language Spanish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull es;)
+ (NSString * _Nonnull)es SWIFT_WARN_UNUSED_RESULT;
/// Language Argentinian Spanish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull es_ar;)
+ (NSString * _Nonnull)es_ar SWIFT_WARN_UNUSED_RESULT;
/// Language Colombian Spanish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull es_co;)
+ (NSString * _Nonnull)es_co SWIFT_WARN_UNUSED_RESULT;
/// Language Mexican Spanish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull es_mx;)
+ (NSString * _Nonnull)es_mx SWIFT_WARN_UNUSED_RESULT;
/// Language Nicaraguan Spanish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull es_ni;)
+ (NSString * _Nonnull)es_ni SWIFT_WARN_UNUSED_RESULT;
/// Language Venezuelan Spanish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull es_ve;)
+ (NSString * _Nonnull)es_ve SWIFT_WARN_UNUSED_RESULT;
/// Language Estonian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull et;)
+ (NSString * _Nonnull)et SWIFT_WARN_UNUSED_RESULT;
/// Language Basque
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull eu;)
+ (NSString * _Nonnull)eu SWIFT_WARN_UNUSED_RESULT;
/// Language Persian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull fa;)
+ (NSString * _Nonnull)fa SWIFT_WARN_UNUSED_RESULT;
/// Language Finnish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull fi;)
+ (NSString * _Nonnull)fi SWIFT_WARN_UNUSED_RESULT;
/// Language French
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull fr;)
+ (NSString * _Nonnull)fr SWIFT_WARN_UNUSED_RESULT;
/// Language Frisian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull fy;)
+ (NSString * _Nonnull)fy SWIFT_WARN_UNUSED_RESULT;
/// Language Irish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ga;)
+ (NSString * _Nonnull)ga SWIFT_WARN_UNUSED_RESULT;
/// Language Scottish Gaelic
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull gd;)
+ (NSString * _Nonnull)gd SWIFT_WARN_UNUSED_RESULT;
/// Language Galician
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull gl;)
+ (NSString * _Nonnull)gl SWIFT_WARN_UNUSED_RESULT;
/// Language Hebrew
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull he;)
+ (NSString * _Nonnull)he SWIFT_WARN_UNUSED_RESULT;
/// Language Hindi
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull hi;)
+ (NSString * _Nonnull)hi SWIFT_WARN_UNUSED_RESULT;
/// Language Croatian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull hr;)
+ (NSString * _Nonnull)hr SWIFT_WARN_UNUSED_RESULT;
/// Language Upper Sorbian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull hsb;)
+ (NSString * _Nonnull)hsb SWIFT_WARN_UNUSED_RESULT;
/// Language Hungarian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull hu;)
+ (NSString * _Nonnull)hu SWIFT_WARN_UNUSED_RESULT;
/// Language Armenian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull hy;)
+ (NSString * _Nonnull)hy SWIFT_WARN_UNUSED_RESULT;
/// Language Interlingua
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ia;)
+ (NSString * _Nonnull)ia SWIFT_WARN_UNUSED_RESULT;
/// Language Indonesian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull id;)
+ (NSString * _Nonnull)id SWIFT_WARN_UNUSED_RESULT;
/// Language Igbo
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ig;)
+ (NSString * _Nonnull)ig SWIFT_WARN_UNUSED_RESULT;
/// Language Ido
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull io;)
+ (NSString * _Nonnull)io SWIFT_WARN_UNUSED_RESULT;
/// Language Icelandic
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull is_is;)
+ (NSString * _Nonnull)is_is SWIFT_WARN_UNUSED_RESULT;
/// Language Italian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull it;)
+ (NSString * _Nonnull)it SWIFT_WARN_UNUSED_RESULT;
/// Language Japanese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ja;)
+ (NSString * _Nonnull)ja SWIFT_WARN_UNUSED_RESULT;
/// Language Georgian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ka;)
+ (NSString * _Nonnull)ka SWIFT_WARN_UNUSED_RESULT;
/// Language Kabyle
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kab;)
+ (NSString * _Nonnull)kab SWIFT_WARN_UNUSED_RESULT;
/// Language Kazakh
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kk;)
+ (NSString * _Nonnull)kk SWIFT_WARN_UNUSED_RESULT;
/// Language Khmer
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull km;)
+ (NSString * _Nonnull)km SWIFT_WARN_UNUSED_RESULT;
/// Language Kannada
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull kn;)
+ (NSString * _Nonnull)kn SWIFT_WARN_UNUSED_RESULT;
/// Language Korean
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ko;)
+ (NSString * _Nonnull)ko SWIFT_WARN_UNUSED_RESULT;
/// Language Kyrgyz
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ky;)
+ (NSString * _Nonnull)ky SWIFT_WARN_UNUSED_RESULT;
/// Language Luxembourgish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull lb;)
+ (NSString * _Nonnull)lb SWIFT_WARN_UNUSED_RESULT;
/// Language Lithuanian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull lt;)
+ (NSString * _Nonnull)lt SWIFT_WARN_UNUSED_RESULT;
/// Language Latvian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull lv;)
+ (NSString * _Nonnull)lv SWIFT_WARN_UNUSED_RESULT;
/// Language Macedonian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull mk;)
+ (NSString * _Nonnull)mk SWIFT_WARN_UNUSED_RESULT;
/// Language Malayalam
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ml;)
+ (NSString * _Nonnull)ml SWIFT_WARN_UNUSED_RESULT;
/// Language Mongolian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull mn;)
+ (NSString * _Nonnull)mn SWIFT_WARN_UNUSED_RESULT;
/// Language Marathi
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull mr;)
+ (NSString * _Nonnull)mr SWIFT_WARN_UNUSED_RESULT;
/// Language Burmese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull my;)
+ (NSString * _Nonnull)my SWIFT_WARN_UNUSED_RESULT;
/// Language Norwegian BokmÃ¥l
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull nb;)
+ (NSString * _Nonnull)nb SWIFT_WARN_UNUSED_RESULT;
/// Language Nepali
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ne;)
+ (NSString * _Nonnull)ne SWIFT_WARN_UNUSED_RESULT;
/// Language Dutch
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull nl;)
+ (NSString * _Nonnull)nl SWIFT_WARN_UNUSED_RESULT;
/// Language Norwegian Nynorsk
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull nn;)
+ (NSString * _Nonnull)nn SWIFT_WARN_UNUSED_RESULT;
/// Language Ossetic
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull os;)
+ (NSString * _Nonnull)os SWIFT_WARN_UNUSED_RESULT;
/// Language Punjabi
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull pa;)
+ (NSString * _Nonnull)pa SWIFT_WARN_UNUSED_RESULT;
/// Language Polish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull pl;)
+ (NSString * _Nonnull)pl SWIFT_WARN_UNUSED_RESULT;
/// Language Portuguese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull pt;)
+ (NSString * _Nonnull)pt SWIFT_WARN_UNUSED_RESULT;
/// Language Brazilian Portuguese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull pt_br;)
+ (NSString * _Nonnull)pt_br SWIFT_WARN_UNUSED_RESULT;
/// Language Romanian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ro;)
+ (NSString * _Nonnull)ro SWIFT_WARN_UNUSED_RESULT;
/// Language Russian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ru;)
+ (NSString * _Nonnull)ru SWIFT_WARN_UNUSED_RESULT;
/// Language Slovak
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sk;)
+ (NSString * _Nonnull)sk SWIFT_WARN_UNUSED_RESULT;
/// Language Slovenian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sl;)
+ (NSString * _Nonnull)sl SWIFT_WARN_UNUSED_RESULT;
/// Language Albanian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sq;)
+ (NSString * _Nonnull)sq SWIFT_WARN_UNUSED_RESULT;
/// Language Serbian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sr;)
+ (NSString * _Nonnull)sr SWIFT_WARN_UNUSED_RESULT;
/// Language Serbian Latin
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sr_latn;)
+ (NSString * _Nonnull)sr_latn SWIFT_WARN_UNUSED_RESULT;
/// Language Swedish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sv;)
+ (NSString * _Nonnull)sv SWIFT_WARN_UNUSED_RESULT;
/// Language Swahili
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull sw;)
+ (NSString * _Nonnull)sw SWIFT_WARN_UNUSED_RESULT;
/// Language Tamil
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ta;)
+ (NSString * _Nonnull)ta SWIFT_WARN_UNUSED_RESULT;
/// Language Telugu
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull te;)
+ (NSString * _Nonnull)te SWIFT_WARN_UNUSED_RESULT;
/// Language Tajik
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull tg;)
+ (NSString * _Nonnull)tg SWIFT_WARN_UNUSED_RESULT;
/// Language Thai
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull th;)
+ (NSString * _Nonnull)th SWIFT_WARN_UNUSED_RESULT;
/// Language Turkmen
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull tk;)
+ (NSString * _Nonnull)tk SWIFT_WARN_UNUSED_RESULT;
/// Language Turkish
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull tr;)
+ (NSString * _Nonnull)tr SWIFT_WARN_UNUSED_RESULT;
/// Language Tatar
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull tt;)
+ (NSString * _Nonnull)tt SWIFT_WARN_UNUSED_RESULT;
/// Language Udmurt
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull udm;)
+ (NSString * _Nonnull)udm SWIFT_WARN_UNUSED_RESULT;
/// Language Ukrainian
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull uk;)
+ (NSString * _Nonnull)uk SWIFT_WARN_UNUSED_RESULT;
/// Language Urdu
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull ur;)
+ (NSString * _Nonnull)ur SWIFT_WARN_UNUSED_RESULT;
/// Language Uzbek
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull uz;)
+ (NSString * _Nonnull)uz SWIFT_WARN_UNUSED_RESULT;
/// Language Vietnamese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull vi;)
+ (NSString * _Nonnull)vi SWIFT_WARN_UNUSED_RESULT;
/// Language Simplified Chinese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull zh_hans;)
+ (NSString * _Nonnull)zh_hans SWIFT_WARN_UNUSED_RESULT;
/// Language Traditional Chinese
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull zh_hant;)
+ (NSString * _Nonnull)zh_hant SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Defiens various logging levels possible to see Nami SDK output - default is “error”, which means only erorrs will be displayed.  Set to “debug” to see as much logging as possible from the SDK.
typedef SWIFT_ENUM(NSInteger, NamiLogLevel, open) {
  NamiLogLevelError = 0,
  NamiLogLevelWarn = 1,
  NamiLogLevelInfo = 2,
  NamiLogLevelDebug = 3,
};

@class NSURLRequest;
@class NSHTTPURLResponse;
@class NSData;

/// Class to let an application be able to ingest logging messages from Nami.
SWIFT_PROTOCOL("_TtP9NamiApple16NamiLoggerClient_")
@protocol NamiLoggerClient <NSObject>
- (void)logHTTPWithRequest:(NSURLRequest * _Nonnull)request response:(NSHTTPURLResponse * _Nonnull)response responseData:(NSData * _Nullable)responseData message:(NSString * _Nonnull)message;
- (void)logMessage:(NSString * _Nonnull)message;
@end


SWIFT_CLASS("_TtC9NamiApple13NamiMLManager")
@interface NamiMLManager : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@interface NamiMLManager (SWIFT_EXTENSION(NamiApple))
/// Labeling method to help train the machine learning.  Use to identify important consumption patterns in your app that you believe drive customer loyalty.  Must be paired with a matching exitCoreContent call with the same label.  Use when your content has a natural hierarchy of tags such as [“images”, “clouds”, “cirrus”]
/// \param labels Set of keywords describing the section of the application entered.
///
+ (void)enterCoreContentWithLabels:(NSArray<NSString *> * _Nonnull)labels;
/// Labeling method to help train the machine learning.  Use to identify important consumption patterns in your app that you believe drive customer loyalty.  Must be paired with a matching exitCoreContent call with the same label.
/// \param label Keyword describing the portion of the app entered.  Machine learning will work best when using somewhat generic labels like “video” or “sports” rather than being very specific like “video_basketball_michael_jordan_dunk”.  Consult https://docs.namiml.com for best practices.
///
+ (void)enterCoreContentWithLabel:(NSString * _Nonnull)label;
/// Labeling method for training machine learning.  Called whenver the user exits a key part of your application.  Labels passed in should match labels passed into a corresponding enterCoreContentPath(labels:) call.
/// \param labels Keywords describing the portion of the app exited, matching labels passed in previously.
///
+ (void)exitCoreContentWithLabels:(NSArray<NSString *> * _Nonnull)labels;
/// Labeling method for training machine learning.  Called whenver the user exits a key part of your application.  Labels passed in should match labels passed into a corresponding enterCoreContent(labels:) call.
/// \param label Keyword describing the portion of the app exited, matching the label passed in previously.
///
+ (void)exitCoreContentWithLabel:(NSString * _Nonnull)label;
/// Labeling method for training machine learning.  Called whenver the user triggers some key action or event within your application.
/// \param label Keyword describing the action triggered by the user.
///
+ (void)coreActionWithLabel:(NSString * _Nonnull)label;
@end


SWIFT_CLASS("_TtC9NamiApple26NamiPaywallComponentChange")
@interface NamiPaywallComponentChange : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC9NamiApple16NamiPaywallEvent")
@interface NamiPaywallEvent : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC9NamiApple18NamiPaywallManager")
@interface NamiPaywallManager : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@class NamiPurchaseSuccess;
@class SKProduct;
@class SKPaymentTransaction;
@class NamiPromo;

@interface NamiPaywallManager (SWIFT_EXTENSION(NamiApple))
/// Provides Nami a callback to activate addiitonal UI required for the user to attempt to log in.  This is called when a paywall is raised that has a “sign in” button the user taps.
/// \param applicationSignInHandler A callback that wil be called at a time Nami is told a sign-in request has been made by a paywall.
///
+ (void)registerSignInHandler:(void (^ _Nullable)(UIViewController * _Nullable))applicationSignInHandler;
/// A hander invoked whenever a Nami paywall is closed.  This handler wil not be invoked for linked paywalls with your own UI.
/// \param paywallCloseHandler A callback that wil be called if a Nami paywall is being closed.
///
+ (void)registerCloseHandler:(void (^ _Nullable)(UIViewController * _Nullable))paywallCloseHandler;
/// Registers a callback that will be activated when user by taps on the Restore Purchases button on a Nami Paywall, so that the application
/// can process the request. This is for customers using Nami for paywalls, but not subscription management.
/// \param restoreRequestHandler A callback called when restore is requested by a user on the Nami Paywall
///
+ (void)registerRestoreRequestHandler:(void (^ _Nullable)(void))restoreRequestHandler SWIFT_DEPRECATED_MSG("", "registerRestoreHandler:");
/// Registers a callback that will be activated when user by taps on the Restore Purchases button on a Nami Paywall, so that the application
/// can process the request. This is for customers using Nami for paywalls, but not subscription management.
/// \param restoreHandler A callback called when restore is requested by a user on the Nami Paywall
///
+ (void)registerRestoreHandler:(void (^ _Nullable)(void))restoreHandler;
/// Registers an optional callback that will activate if a button on a paywall is setup to trigger a deeplink action.  By default, the SDK will dismiss the paywall
/// and open the deeplink via the operating system. If this handler is registered, it will be called instead so the app can implement custom logic.
/// \param deeplinkActionHandler A callback that wil be called at a time Nami is told a sign-in request has been made by a paywall.
///
+ (void)registerDeeplinkActionHandler:(void (^ _Nullable)(NSString * _Nonnull))deeplinkActionHandler;
/// Registers a callback that will be activated when a user triggers a buy sku action on a paywall.
/// Only available for plans where Nami is not handling subscription & IAP purchase management.
/// \param buySkuHandler A callback called when a buy sku action takes place
///
+ (void)registerBuySkuHandler:(void (^ _Nullable)(NamiSKU * _Nonnull))buySkuHandler;
/// Notify the NamiPaywallManager that an App Store in-app purchase handled by you is complete.
/// Only available for apps in which Nami is not handling subscription & IAP management.
/// \param purchaseSuccess A NamiPurchaseSuccess object for the purchase.
///
+ (void)buySkuCompleteWithPurchaseSuccess:(NamiPurchaseSuccess * _Nonnull)purchaseSuccess;
/// Notify the NamiPaywallManager that a StoreKit 2 purchase handled by you is complete.
/// Only available for apps in which Nami is not handling subscription & IAP management.
/// \param sku A <code>NamiSKU</code> object passed to you by <code>NamiPaywallBuySkuHandler</code>
///
/// \param product A StoreKit 1 <code>SKProduct</code> object used to make the purchase.
///
/// \param transaction A StoreKit 1 <code>SKPaymentTransaction</code> object for the purchase.
///
+ (void)buySkuCompleteWithSku:(NamiSKU * _Nonnull)sku product:(SKProduct * _Nonnull)product transaction:(SKPaymentTransaction * _Nonnull)transaction;
/// Notify the NamiPaywallManager that an App Store in-app purchase flow handled by you is cancelled.
/// Used to disable product purchase-in-progress loading indicators
+ (void)buySkuCancel;
/// Call in the case when you want to be sure a Nami paywall will have been closed
/// \param animated True for standard UIKit animation of dismissal, false otherwise.
///
/// \param completion Completion handler to be called when paywall is dismissed, may be immediate if not presented.
///
+ (void)dismissWithAnimated:(BOOL)animated completion:(void (^ _Nonnull)(void))completion;
/// Call to obtain a currently raised Nami Paywall view controller, will be .none if the paywall is closed.  Useful if you wish to present status alerts or other modal UI on top of a Nami paywall.
/// <ul>
///   <li>
///     Returns The view controller of a raised nami paywall, .none otherwise.
///   </li>
/// </ul>
+ (UIViewController * _Nullable)displayedViewController SWIFT_WARN_UNUSED_RESULT;
/// Used when a paywall is presented via a nami window to show the window if it’s currently hidden. Advanced use case.
+ (void)show;
/// Used when a paywall is presented via a nami window to find out if the paywall is currently hidden. Advanced use case.
+ (BOOL)isHidden SWIFT_WARN_UNUSED_RESULT;
/// Used when a paywall is presented via a nami window to hide the window if it’s currently showing. Advanced use case.
+ (void)hide;
/// Use this to check if a paywall is currently being shown to the end user
+ (BOOL)isPaywallOpen SWIFT_WARN_UNUSED_RESULT;
/// Receive a signed signature for applying to a promotion. Requires a proper entitlement to use.
+ (void)getSignedPromoWithSkuId:(NSString * _Nonnull)skuId promoId:(NSString * _Nonnull)promoId completeHandler:(void (^ _Nullable)(NamiPromo * _Nullable))completeHandler;
@end


SWIFT_CLASS("_TtC9NamiApple18NamiProductManager")
@interface NamiProductManager : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end




SWIFT_CLASS("_TtC9NamiApple9NamiPromo")
@interface NamiPromo : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSDate;
enum NamiPurchaseSource : NSInteger;

SWIFT_CLASS("_TtC9NamiApple12NamiPurchase")
@interface NamiPurchase : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull skuId;
@property (nonatomic, copy) NSString * _Nullable transactionIdentifier;
@property (nonatomic, copy) NSDate * _Nonnull purchaseInitiatedTimestamp;
@property (nonatomic, copy) NSDate * _Nullable expires;
@property (nonatomic) enum NamiPurchaseSource purchaseSource;
@property (nonatomic) NSInteger consumptionCount;
@property (nonatomic, readonly, copy) NSArray<NamiEntitlement *> * _Nonnull entitlementsGranted;
- (nonnull instancetype)initWithProductIdentifier:(NSString * _Nonnull)productIdentifier purchaseSource:(enum NamiPurchaseSource)purchaseSource OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) BOOL isSubscription;
@property (nonatomic, strong) NamiSKU * _Nullable sku;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum NamiPurchaseState : NSInteger;
enum NamiRestorePurchasesState : NSInteger;

/// Class to work with and manage purchases on the device.
SWIFT_CLASS("_TtC9NamiApple19NamiPurchaseManager")
@interface NamiPurchaseManager : NSObject
/// Checks to see if a SkuId (product app for Apple devices) has been purchased by the current device owner or not.
/// \param skuID ID of SKU you wish to check for purchase status
///
///
/// returns:
/// true if the SKU has been purchased, false otherwise.
+ (BOOL)skuPurchased:(NSString * _Nonnull)skuId SWIFT_WARN_UNUSED_RESULT;
/// Checks to see if any one of an array of SKUID (product app for Apple devices) has been purchased by the current device owner or not.
/// \param skuIDs Array of IDs of SKU you wish to check for purchase status
///
///
/// returns:
/// true if any SKU in the passed in array has been purchased, false otherwise.
+ (BOOL)anySkuPurchased:(NSArray<NSString *> * _Nonnull)skuIds SWIFT_WARN_UNUSED_RESULT;
/// Checks to see if a SKUID (product app for Apple devices) has been purchased, and returns the purchase record if found (holds things like purchase and expiration date if known).
/// \param skuID ID of SKU you wish to check for purchase status
///
///
/// returns:
/// NamiPurchase if found, .none otherwise.
+ (NamiPurchase * _Nullable)getRecordForSKU:(NSString * _Nonnull)skuId SWIFT_WARN_UNUSED_RESULT;
/// Takes in a set of SKUIDs (productIDs for Apple) and loads NamiSKU objects with StoreKIt and other metadata, so that you can examine product details or use for other calls.  If you pass in SKUIDs the system does not recognize, they will be returned as invalid and no NamiSKU objects will be returned for those IDs.
/// \param skuIDs ID of SKU you wish to check for purchase status
///
/// \param productHandler A callback to be given the loaded NamiSKU objects from the IDs you passed in, along with an array of invalid IDs the system could not load.
///
+ (void)skusForSKUIdsWithSkuIds:(NSArray<NSString *> * _Nonnull)skuIds productHandler:(void (^ _Nonnull)(BOOL, NSArray<NamiSKU *> * _Nullable, NSArray<NSString *> * _Nullable, NSError * _Nullable))productHandler;
/// Returns all known purchases for the current device.
///
/// returns:
/// NamiPurchase objects if any purchases are found, an empty array otherwise.
+ (NSArray<NamiPurchase *> * _Nonnull)allPurchases SWIFT_WARN_UNUSED_RESULT;
/// Registers a callback that will be activated when any purchase activity occurs - either purchases or expiration.
/// \param responseHandler A callback called when StoreKit purchase changes in the system are detected.
///
///
/// returns:
/// NamiPurchase objects if any purchases are found, an empty array otherwise.
+ (void)registerPurchasesChangedHandler:(void (^ _Nullable)(NSArray<NamiPurchase *> * _Nonnull, enum NamiPurchaseState, NSError * _Nullable))responseHandler;
/// Registers a callback that will be activated when any purchase activity occurs - either purchases or expiration.
/// \param changeHandler A callback called when StoreKit purchase changes in the system are detected.
///
///
/// returns:
/// NamiPurchase objects if any purchases are found, an empty array otherwise.
+ (void)registerWithPurchasesChangedHandler:(void (^ _Nullable)(NSArray<NamiPurchase *> * _Nonnull, enum NamiPurchaseState, NSError * _Nullable))changeHandler SWIFT_DEPRECATED_MSG("", "registerPurchasesChangedHandler:");
/// Registers a callback that will be activated when restore purchases in invoked (by tapping the Restore Purchases button on a Nami Paywall or by starting the restore purchases process directly), so that the application can react to the restore purchase process and potentially provide information in the UI about the restore process.
/// \param changeHandler A callback called when StoreKit restore purchases has been activated or finishes.
///
+ (void)registerRestorePurchasesHandlerWithRestorePurchasesStateHandler:(void (^ _Nullable)(enum NamiRestorePurchasesState, NSArray<NamiPurchase *> * _Nonnull, NSArray<NamiPurchase *> * _Nonnull, NSError * _Nullable))changeHandler;
/// Activates the system restore purchases feature, and calls back to a global <code>NamiRestorePurchasesStateHandler</code> handler with status if one is provided by
/// <code>registerRestorePurchasesHandler</code>. Restore replays all prior purchase transactions to determine which purchases are active.  This function trigger an app store password prompt if called, so only call this at the request of the user.  Generally this is not needed if your Nami account supports receipt validation, as the receipt is checked every time the app comes to the foreground and can determine active purchases that way.
+ (void)restorePurchases;
/// Activates the system restore purchases feature, and calls back to the provided <code>statehandler</code>.  Restore replays all prior purchase transactions to determine which purchases are active.  This function mau trigger an app store password prompt if called, so only call this at the request of the user.  Generally this is not needed if your Nami account supports receipt validation, as the receipt is checked every time the app comes to the foreground and can determine active purchases that way.
/// \param handler A callback called when the restore process is complete, with state indicators and all known purchases found.
///
+ (void)restorePurchasesWithStatehandler:(void (^ _Nonnull)(enum NamiRestorePurchasesState, NSArray<NamiPurchase *> * _Nonnull, NSArray<NamiPurchase *> * _Nonnull, NSError * _Nullable))statehandler;
/// Activates the system restore purchases feature, which replays all prior purchase transactions to determine which purchases are active.  This may trigger an app store password prompt if called, so only call this at the request of the user.  Generally this is not needed if your Nami account supports receipt validation, as the receipt is checked every time the app comes to the foreground and can determine active purchases that way.
/// \param handler A callback called when the restore process is complete, with success flag and errors (if any)
///
+ (void)restorePurchasesWithHandler:(void (^ _Nonnull)(BOOL, NSError * _Nullable))handler SWIFT_DEPRECATED;
/// For consumable purchases only, tells the system a purchase has been consumed - that is to say, your application has altered the application permanently to account for the purchase.  If you do not consume a consumable purchase, the purcahse will come back with every application launch.
/// \param skuID The ID (product ID for Apple) of the product you wish to consume - note that it must be purchased or this call will do nothing.
///
+ (void)consumePurchasedSkuWithSkuId:(NSString * _Nonnull)skuId;
/// Prompts iOS to show the system Subscription Offer Code redemption sheet, which the user can then enter a redemption code into.
/// Note that this call will do nothing on pre-ios14 devices, which do not implement that call and cannot redeem offer codes.
+ (void)presentCodeRedemptionSheet;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// The source a purchase comes from - either direct on the App Store, or through a paywall in-app controlled by a Nami campaign
typedef SWIFT_ENUM(NSInteger, NamiPurchaseSource, open) {
  NamiPurchaseSourceCampaign = 0,
  NamiPurchaseSourceMarketplace = 1,
  NamiPurchaseSourceUnknown = 2,
};

/// The various states a purcahse can be in depending on what is happening in StoreKit.
typedef SWIFT_ENUM(NSInteger, NamiPurchaseState, open) {
  NamiPurchaseStatePending = 0,
  NamiPurchaseStatePurchased = 1,
  NamiPurchaseStateConsumed = 2,
  NamiPurchaseStateResubscribed = 3,
  NamiPurchaseStateUnsubscribed = 4,
  NamiPurchaseStateDeferred = 5,
  NamiPurchaseStateFailed = 6,
  NamiPurchaseStateCancelled = 7,
  NamiPurchaseStateUnknown = 8,
};


SWIFT_CLASS("_TtC9NamiApple19NamiPurchaseSuccess")
@interface NamiPurchaseSuccess : NSObject
- (nonnull instancetype)initWithProduct:(NamiSKU * _Nonnull)product transactionID:(NSString * _Nonnull)transactionID originalTransactionID:(NSString * _Nonnull)originalTransactionID price:(NSDecimal)price currencyCode:(NSString * _Nonnull)currencyCode OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Wimple wrapper around IAP JSON from an Apple parsed StoreKit receipt.  Note you can always get the original IAP product dict from the parsed receipt via the iapJSONDict property.
SWIFT_CLASS("_TtC9NamiApple21NamiReceiptIAPWrapper")
@interface NamiReceiptIAPWrapper : NSObject
/// The orignal JSON values from the Apple receipt data.
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull iapJSONDict;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum StoreKitEnvironmentObjC : NSInteger;

SWIFT_CLASS("_TtC9NamiApple18NamiReceiptWrapper")
@interface NamiReceiptWrapper : NSObject
/// The raw JSON data returned from Apple processing the receipt data sent from your device.
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull receiptJSONDict;
/// Lets you know if there’s any receupt data to lok at, in cases of varous errors or passive mode, you’ll not have receipt data from a validation call.
@property (nonatomic, readonly) BOOL hasReceiptData;
/// Lets you know if the error messages mean your shared secret may not be set correctly.
@property (nonatomic, readonly) BOOL possibleReceiptSharedSecretIssue;
/// The status code for this attempt at receipt validation.
@property (nonatomic, readonly) NSInteger statusCode;
/// The current StoreKit environment, for objective C.
@property (nonatomic, readonly) enum StoreKitEnvironmentObjC storeKitEnvironmentObjC;
/// The original application version when the user first purchased/downloaded your application, so you know when they started using your application.
- (NSString * _Nullable)originalApplicationVersion SWIFT_WARN_UNUSED_RESULT;
/// Full iAP receipt dictionary values.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)fullIAPReceiptInfoDict SWIFT_WARN_UNUSED_RESULT;
/// Latest receipt dictionary values.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)latestReceiptInfoDict SWIFT_WARN_UNUSED_RESULT;
/// Latest receipt dictionary values.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)inAppItems SWIFT_WARN_UNUSED_RESULT;
/// All of the IAP items from the receipt, sorted by date so the newest onese are on top.
- (NSArray<NamiReceiptIAPWrapper *> * _Nonnull)sortedIAPItemsFromDate:(NSDate * _Nonnull)fromDate SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, NamiRestorePurchasesState, open) {
  NamiRestorePurchasesStateStarted = 0,
  NamiRestorePurchasesStateFinished = 1,
  NamiRestorePurchasesStateError = 2,
};

enum NamiSKUType : NSInteger;

/// Object that is an abstraction of the products setup in App Store Connect as per the products section of the Nami Control Center.
SWIFT_CLASS("_TtC9NamiApple7NamiSKU")
@interface NamiSKU : NSObject
/// Internal Nami identifier for the product, exposed to conform to the Identifiable protocol so a list of NamiSKUs can be used easily in SwiftUI inside of a ForEach, etc.
@property (nonatomic, copy) NSString * _Nonnull id;
/// The Platform speciifc ID, or productIdentifier for Apple platforms.
@property (nonatomic, copy) NSString * _Nonnull skuId;
/// Reference Name field for this product in the Nami Control Center
@property (nonatomic, copy) NSString * _Nullable name;
/// Type of product -  <code>subscription</code> or  <code>one_time_purchase</code>.
@property (nonatomic) enum NamiSKUType type;
/// Any entitlements this product is associated with in the Nami Control Center
@property (nonatomic, copy) NSArray<NamiEntitlement *> * _Nonnull associatedEntitlements;
/// The App Store promo ID if provided
@property (nonatomic, copy) NSString * _Nullable promoId;
/// If available, the local system object for this product.  For SKU types not of the current platform, this will always be empty.
@property (nonatomic) id _Nullable product;
- (nonnull instancetype)initWithNamiId:(NSString * _Nonnull)namiId storeId:(NSString * _Nonnull)storeId skuType:(enum NamiSKUType)skuType OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The possible types of products for Apple devices - either one time purchase (consumable/nonconsumable) or subscription.
typedef SWIFT_ENUM(NSInteger, NamiSKUType, open) {
  NamiSKUTypeUnknown = 0,
  NamiSKUTypeOne_time_purchase = 1,
  NamiSKUTypeSubscription = 2,
};


/// Class to help with some aspects of direct StoreKit access.
SWIFT_CLASS("_TtC9NamiApple18NamiStoreKitHelper")
@interface NamiStoreKitHelper : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NamiStoreKitHelper * _Nonnull shared;)
+ (NamiStoreKitHelper * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Identifier for times when the system needs to return a namiSKU, but there’s no real product behind that wrapper.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull noProductIdentifier;)
+ (NSString * _Nonnull)noProductIdentifier SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull objCStoreKitEnvironment;
/// Verifies any already local receipt the app may have by sending the receipt data to the Nami server, which calls Apple for the most recent receipt data.
- (void)verifyReceiptWithCompletion:(void (^ _Nonnull)(NamiReceiptWrapper * _Nullable))completion;
/// Last app receipt json obtained, if any.
+ (NamiReceiptWrapper * _Nullable)appReceipt SWIFT_WARN_UNUSED_RESULT;
@end



SWIFT_CLASS("_TtC9NamiApple20PaywallLaunchContext")
@interface PaywallLaunchContext : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface SKProduct (SWIFT_EXTENSION(NamiApple))
/// Builds a simple dictionary for a product that holds price, locale, and currency values for this product.
- (NSDictionary<NSString *, id> * _Nonnull)namiInfoDict SWIFT_WARN_UNUSED_RESULT;
- (NSDictionary<NSString *, id> * _Nonnull)namiInfoDictWithPurchaseSource:(enum NamiPurchaseSource)_ SWIFT_WARN_UNUSED_RESULT;
@end



/// This enum represents the possible time units for adjusting simulated sandbox acceleration - the reduction of real-world time into smaller units for testing purposes when bypassStore is enabled.
typedef SWIFT_ENUM(NSInteger, SandboxAccelerationItemUnit, open) {
  SandboxAccelerationItemUnitHour = 0,
  SandboxAccelerationItemUnitWeek = 1,
  SandboxAccelerationItemUnitMonth = 2,
  SandboxAccelerationItemUnitSixMonth = 3,
  SandboxAccelerationItemUnitYear = 4,
};

/// Objective-C enum for store kit environments as there are no String enums in Objective-C.
typedef SWIFT_ENUM(NSInteger, StoreKitEnvironmentObjC, open) {
  StoreKitEnvironmentObjCProduction = 0,
  StoreKitEnvironmentObjCSandbox = 1,
  StoreKitEnvironmentObjCNamiStoreKitBypass = 2,
  StoreKitEnvironmentObjCEnvironmentNotYetDetected = 3,
};


SWIFT_CLASS("_TtC9NamiApple19StoreKitQueueHelper")
@interface StoreKitQueueHelper : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Possuble status codes from StoreKit.  The msot likley one to be seen is 21004, which measns Nami does not have the shared sescret it needs to send your receipts to Apple.  Add in the Nami Control Center developer tab.
typedef SWIFT_ENUM(NSInteger, StoreKitStatusCodes, open) {
  StoreKitStatusCodesStatusOK = 0,
  StoreKitStatusCodesUnreadableJSON = 21000,
  StoreKitStatusCodesReceiptMalformed = 21002,
  StoreKitStatusCodesReceiptAuthFailed = 21003,
  StoreKitStatusCodesSharedSecretInvalid = 21004,
  StoreKitStatusCodesReceiptServerUnavailable = 21005,
  StoreKitStatusCodesSubscriptionExpired = 21006,
  StoreKitStatusCodesReceiptFromSandboxEnvironment = 21007,
  StoreKitStatusCodesReceiptFromProdEnvironent = 21008,
  StoreKitStatusCodesNamiError = 99999,
};







#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#endif
